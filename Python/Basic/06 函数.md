## 函数的定义和调用

在函数内书写的代码块可以通过调用相应函数的形式重复使用。并且可以通过改变参数的形式改变代码的运行。

一般来说，一个函数只实现一个功能。这样可以使得代码的耦合性更低。这是比较好的编程习惯。

### 定义

```python
def 函数名(形数表):
	函数体
```

> 返回值为多个值时，返回元组
### 调用

```python
函数名(实参表)
```

> 注意，函数的定义必须在调用之前，否则将会认为函数未定义。
### 函数的执行过程
函数体中的代码默认不会被执行。只有在调用时才会开始执行。调用结束后返回原处继续从下到下的执行语句，
```python
def fun(a):
	print(a)

fun(1)
fun(2)
fun(3)
```
这段代码实现的功能相当于：
```python
print(1)
print(2)
print(3)
```
## 函数的参数

参数实际相当于在函数内定义了相应数量的变量，其作用域为函数体（也就是只在函数体内生效）。其实际值为调用函数时传入的值。

这个被传入的值称为实参，函数接收参数所用的变量称为形参。

```python
#定义一个有两个参数的函数
def name(a,b):
	pass

#调用函数并传递参数
name(1,2)	#按位置传递，a给a，2给b
name(b=2,a= 1)	#按关键字传递，2给b，1给a
```
位置传参和关键字传参可以混合使用，在混合使用时，一般要位置实参在关键字实参之前。

> 这是为了配合有默认值的参数，一般来说，我们更多的使用位置传参。
> 
> 很多情况下，我们在调用函数时不需要关心有默认值的参数，但有些时候，我们需要改变这些参数，
> 
> 所以我们可以使用位置参数来传递函数必须的参数，然后通过关键字改变那些我们关心的有默认值的参数。 

>默认情况下，实参与形参的个数必须相等。

> 如果参数为可变对象，形参值的修改会影响实参值
> 
>如果参数为不可变对象，形参值的修改不会影响实参值

### 将序列转换为实参

```python
def name(a,b,c):
	pass
lst = [10,20,30]
dic = {'a':1,'b':2,'c':3}
name(*lst)	#将列表的每个元素转换为位置实参传入
name(**dic)	#将字典的每个键值对转换为关键字实参传入
```

> 元组，集合等其他序列也可以转换为位置实参

### 让形参拥有默认值
形参的默认值，就是形参在没有实参的时候所具有的值。

当形参拥有默认值以后，便可以不给其传递实参。

当没有给具有默认值的形参传递实参，有默认值的形参便使用默认值。如果传入了实参，则形参的值为实参的值。
```python
def name(a=1,b=2):	#可以设置参数的默认值
	pass
```

> 一般来说，我们将含有默认值的参数放在参数表的最后面。
> 
> 如果放在前面，在按位置传参时可能会出现有默认值的参数被传递了实参，没有默认值的参数没有被传入实参的情况

###  个数可变的参数

> 个数可变的位置参数和个数可变的关键字参数一个函数里只能各自存在一个。
>
> 如果同时有个数可变的位置参数和个数可变的关键字参数时，个数可变的位置参数应当写在个数可变的关键字参数之前,如：
>
> ```python
> def name(*args1,**args2)
> ```

#### 个数可变的位置参数
使用`*`来标识一个个数可变的位置参数。

```python
def name(*args):	#一个个数可变的位置参数
```
在调用时，多个位置参数将会被储存在一个元组中传给个数可变的位置参数
```python
name(10,20,30)	# 10，20，30将以元组（10，20，30）的形式传给args
```
#### 个数可变的关键字参数
使用`**`来标识一个个数可变的位置参数。
```python
def name(**args):
```
在调用时，多个关键字参数将会被储存在一个元组中传给个数可变的位置参数
```python
name(a=1,b=2,c=3)	# a=1,b=2,c=3 将以字典{'a':1,'b':2,'c':3}的形式传给args
```
## 函数的返回值
函数除了可以通过参数表接收数据，也可以通过返回值的形式返回数据。
```python
def 函数名(参数表):
	pass
	return 返回值
```

使用`return`语句使得函数返回一个返回值。

在函数执行时，如果遇到`return`语句，则结束执行并返回，不会继续执行`return`后的的语句。

函数可以不返回任何东西，`return`并不是必须的。没有`return`语句函数也能正常执行

`return`语句也可以不返回任何值。只用作结束函数的执行。
```python
def 函数名(参数表):
	pass
	return #此处吧返回任何值
```

一个函数体内可以有多个`return`语句，但实际上只会有一个`return`语句最终被执行了。

返回值可以是一个变量，也可以是多个变量。

如果是多个变量，可以用一个变量接收，也可以用多个变量接收。

如果用一个变量接收，将会将多个变量储存在一个元组中，返回这个元组。

```python
def 函数名(参数表):
	return a,b
```
## 函数的多重调用
### 函数的链式调用
函数的链式调用，就是使用一个函数的返回值作为另一个函数的参数

```python
#打印sum
def print_sum(sum):
	print(sum)

# 算出变量 a 和 b 的和
def add(a,b):
	return a + b

# 链式调用print_sum和add
print_sum(add(1,3))
```
上述程序最终会打印3

### 函数的嵌套调用
在函数内调用函数，称为函数的嵌套调用
```python
def fun1():
	print(add(1,2))

def add(1,2):
	return a + b	
```
fun1嵌套调用了函数print和函数add。函数print和add是一个链式调用。
### 函数的递归
函数在自己的函数体内调用自己称为递归

递归的两个要素：
1. 递归结束条件
2. 递推公式
```python
def fun(a):
	if(a < 10)
		print(a)
		fun(a+1)
	else
		return 

fun(1)
```
这段代码在功能上等价于
```python
for a in range(1,10):
	print(a)
```
### 递归的要素 
递归的两个要素：
1. 递归结束条件
2. 递推公式
#### 结束条件有误
如果结束条件不正确，很容易无限递归下去
```python
# 无限递归
def fun(a):
	if(a > 0)
		print(a)
		fun(a+1)
	else
		return 

fun(1)
```
这段代码在功能上等价于：
```python
# 死循环
a = 1
while a>0:
	print(a)
	a += 1
```
#### 递推公式有误
递推公式有误可能造成错误的运行结束
```python
def fun(a):
	if(a > 10)
		print(a)
		fun(a)
	else
		return 

fun(1)
```
本意为打印1-10，结果无限打印1
### 递归的优劣
优点：
1. 代码更简洁
2. 逻辑更明确，写起来容易
缺点：
1. 占用更多
2. 执行更慢