启动一个软件就是启动了一个进程。

> 启动软件时,要将软件加载入内存，此时操作系统创建一个进程来调度这个软件。

> 在Linux下,命令本身也是程序,运行命令时也创建了一个进程。

进程 = 软件对应的代码和数据 + 描述这个软件的PCB结构体

## PCB

PCB全称为process control block

每创建一个进程,操作系统会创建一个PCB的结构体,这个结构体描述了此进程的所有属性。

PCB结构体的具体名称在比特系统中并不相同,在Linux下,这个结构体的名称为`tast_struct`

tast_strcut的属性:
- 标示符: 描述本进程的唯一标示符，用来区别其他进程。
- 状态: 任务状态，退出代码，退出信号等。
- 优先级: 相对于其他进程的优先级。
- 程序计数器: 程序中即将被执行的下一条指令的地址。
- 内存指针: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针上下文数据: 进程执行时处理器的寄存器中的数据\[休学例子，要加图CPU，寄存器\]。
- I／O状态信息: 包括显示的I/O请求,分配给进程的I／O设备和被进程使用的文件列表
- 记账信息: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。
- 其他信息

## 查看进程信息

可以在内核源代码里找到它。所有运行在系统里的进程都以task_struct链表的形式存在内核里。

每个进程都有一个PID。在C语言中,可以通过`gitpid()`来获取本程序的PID;

查看进程进程的信息可以通过`/proc`系统文件夹查看如：要获取PID为1的进程信息，你需要查看`/proc/1`这个文件夹。

大多数进程信息同样可以使用top和ps这些用户级工具来获取

即时监视进程信息(相当于widows下的任务管理器)：
```shell
top
```
打印当前进程信息（常用）：
```shell
ps ajx
```
- a:显示所有进程
- x:改变显示的格式

> 文件夹是动态创建的,每多一个进程， /proc下就会多一个以此进程的pid为名的文件夹,保存这个进程的信息,进程结束时,文件夹销毁。

## 进程优先级
PRI为进程的优先级，PRI值越小，优先级越高。

NI（nice）是优先级的修正值，用来修改PRI的值，取值为\[-20，19\]。

> new PRI = oldPRI + nice；

**修改优先级：**进入top后按下r，输入进程PID后输入nice值，默认情况下，oldPRI = 80；

## 进程的特性
- 竞争性: 系统进程数目众多，而CPU资源只有少量，甚至1个，所以进程之间是具有竞争属性的。为了高效完成任务，更合理竞争相关资源，便具有了优先级
- 独立性: 多进程运行，需要独享各种资源，多进程运行期间互不干扰
- 并行: 多个进程在多个CPU下同时运行，这称之为并行
- 并发: 多个进程在一个CPU下采用进程切换的方式，在一段时间之内，让多个进程都得以推进，称之为并发

>一个CPU同时只能运行一个进程。CPU调度代码的时候是以并发的形式调度的；
> 一个进程进入CPU后运行一个时间片的时间，然后切换到下一个进程，如果进程结束，则退出运行态。否则继续在运行队列中排队。
> 这也就有了抢占与出让的概念，当遇到优先级高的进程，会直接抢占原来的运行队列，进行插队。
## 进程的继承关系
进程间是有继承关系的，每个进程的PPID标识了其父进程的PID

在C语言中，可以通过`gitppid()`函数来获取本程序的PPID

每次登录云服务器，都会创建一个新的base进程，这个进程是你在此次登录中启动的所有进程的父进程。

C语言可以通过`fork()`来创建一个子进程。

fork()创建成功时给父进程返回子进程的pid,给子进程返回0。创建失败时返回-1。

也就是说fork有两个返回值，这是因为fork创建了一个子进程，现在同一个程序使用同一个代码（使用写时拷贝），但是数据分开保存。
```C
pid_t pid = fork()
printf("hello C\n");
```
> 在上面的程序中,hello C被打印两次,因为创建了一个子进程,父子进程代码共享,都运行了一次`printf("hello C\n");`

一般来说,fork后需要用if分流:
```C
pid_t pid = fork()
if(pid == -1){
	printf("fork fail");
	exit();
}else if(pid == 0){
	printf("hello subprocess");
}else{
	printf("hello parent process");
}
```

## 进程的状态

tast_struct被组织为队列。每个资源都有一个队列。CPU队列，显卡队列等。当进程需要调用某种资源时，就会加入相应的队列。

CPU队列称为运行队列。

**操作系统理论中的进程状态：**

- 运行态（R running）：进程在运行队列中。
- 阻塞态：等待非CPU资源就绪。可能是资源被其他进程占用，或是等待相应资源返回值。
- 挂起态：当内存不足的时候，将阻塞或是其他原因导致长时间闲置的进程暂时置换到磁盘中。

**linux的进程具有的实际状态：**
- 运行状态（R running）：进程在运行队列中。
- 睡眠状态（S sleeping）：可中断睡眠状态，也就是可以使得其进入运行态。
- 磁盘睡眠（D disk sleep）：磁盘睡眠，深度睡眠，不可以被被动唤醒。
- 暂停状态（T stopping）：暂停状态，调试状态（程序被调试时处于次状态）。
- （T tracing stop）：
- 僵尸状态（Z zombie）：进程已经退出，但正在被OS或父进程检测，不允许被释放。
- 终止状态（X dead）：进程运行结束，可以被销毁。此状态非常短暂，几乎无法查看。
> 进程分为前台进程和后台进程，后台进程不影响命令行交互。状态后使用+标识为前台进程，无标识为后台状态。

Linux2.6内核中描述进程状态的数组：
```C
static const char* tast_state_array[] = {
	"R (running)" /* 0 */
	"S (sleeping)",/* 1 */
	"D (disk sleep)",/* 2 */
	"T (stopping)",/* 4 */
	"T (tracing stop)",/* 8 */
	"Z (zombie)",/* 16 */
	"X (dead)"/* 32 */
}
```

使得进程终止
```shell
kill -9 PID
```

## 僵尸进程

### 孤儿进程
如果子进程还没退出,而父进程退出了,此时子进程的父进程会变为init(被init领养);

init进程的PID为1，是系统本身；

## 上下文数据

进程存入寄存器中的临时数据，称作上下文数据。

**上下文数据绝对不可以被丢弃**

当进程从CPU中被切换下来的时候，需要带走自己的上下文数据，以便下次进入CPU的时候继续按照之前的状态向下执行。如同没有中断过一样。
## 进程地址空间
从高到低为：

- 栈区
- 
- 堆区
- 未初始化全局区
- 已初始化全局数据区
- 代码区

堆区向下增长，栈区向下增长。其他区空间固定；


