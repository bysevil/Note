为什么要有库

1. 方便：用户只需要拿到库文件和头文件就能使用
2. 代码安全：库是2进制文件，无法直接看到源代码
## C标准库

头文件的位置存储在`usr/include/`目录下

库文件的位置存储在`/lib64/`

在Linux下:
- `.so`叫做动态库
- `.a`叫做静态库

在Windows下
- `.dll`称作动态库
- `.lib`称作静态库
## 静态库与动态库


动态链接库被使用时：将动态链接库的位置告诉程序，程序运行时找到动态链接库，动态链接库执行。

动态库可以和程序分批加载，当程序执行到库中的代码，才将库代码加载入内存，建立页表，将页表加载到进程空间的更共享区。

当多个进程使用动态库时，只需要将页表拷贝到进程的共享区，就可以使用动态库，动态库实际上只需要加载到内存一次，就可以被多个进程使用。

静态链接库被使用时：将静态链接库中的代码拷入自己的程序，直接在自己的程序中执行。

所以静态库的代码直接被拷贝到进程的代码区。当多个进程使用静态库时，要给每个进程拷贝一次库代码。

所以静态库编译出来的程序会比较大，但是运行时不需要库文件。静态库编译出来的程序会比较小，但是运行时需要设备上有库文件。

### 打包自己的库

#### 打包成静态库

1. 编译成可重定向目标文件（`.o`文件）
```shell
gcc -c 源文件 -o 可重定向目标文件
```
2. 打包成静态库
```shell
ar -rc 库名 可重定向目标文件名
```
> 库名一般使用`lib`开头，静态库使用`.a`后缀

#### 打包成动态库

1. 编译成与位置无关可重定向目标文件（`.o`文件）
```shell
gcc -fPIC -c 源文件 -o 与位置无关可重定向目标文件
```
2. 打包成动态库
```shell
gcc -shared 与位置无关可重定向目标文件 -o 库名
```
> 库名一般使用`lib`开头，静态库使用`.so`后缀
### 使用别人的库

如果具有同名动静态库

默认使用动态链接库，如果只有静态库，将只能进行静态链接。

如果具有动态库，则使用动态链接。如果此时想要使用静态库，需要指明`-static`

```shell
gcc -o 可执行文件名 源文件名 -l 库文件名 -static
```

#### 方法1：复制到系统目录使用
头文件默认目录：/usr/include
库文件默认目录：/lib64 和 /usr/lib64

将库文件和头文件复制到系统路径的过程叫做安装库，删除的过程叫做卸载库。

因为我们的库是第三方库，所以编译器无法自动链接，我们需要手动链接库。

```shell
gcc -o 可执行文件名 源文件名 -l 库文件名
```

注意，库文件名不包含后缀和前缀的lib，如`libhello.a` 库名使用`-l hello`

> 一般不建议将自己的库放在系统目录，因为不安全。

#### 方法2：直接使用

我们可以直接使用库，但需要给出头文件路径，库文件路径，库文件名

```shell
gcc -o 可执行文件名 源文件名 -I 头文件目录 -L 库文件目录 -l 库文件名
```

如果目标是动态库，还需要告诉加载器动态库的路径，否则加载器加再不了动态库。
我们需要编辑加载器的环境变量，使得加载器能找到动态库：
更改本次登录环境：
```shell
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:动态库路径
```
更改系统环境：
`\etc\ld.so.conf\`路径下的所有文件内的路径都是加载器的加载路径。我们只需要新建一个conf文件，并且将动态库的路径直接存入这个文件即可。

#### 方法3：建立链接

使用动态库时，如果没有把库放在系统目录，则需要告诉加载器库文件的目录。

我们也可以直接在系统目录建立链接，链接到动态库。这样也可以直接使用。

> 不推荐
