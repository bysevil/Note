### 临界资源与临界区
临界资源：多个执行流共享的资源
临界区：执行流内部访问临界资源的代码‘
互斥：保证只有一个执行流进入临界区，访问临界资源
原子性：只有完成和未完成两种状态，不会被打断（也就是可以认为其没有执行过程的资源具有原子性，是资源的基本单位）
### 可重入函数

函数被重入（Function Reentrancy）是指在一个程序中，同一个函数在执行过程中可能被中断，然后重新进入执行。
>在多线程编程中，如果一个函数在执行过程中被另一个线程调用，那么这个函数就会被重入
>如果收到信号转去处理信号，处理结束后回到函数继续向下执行，也称作被重入

如果重入行为不影响函数的正确性或结果。则此函数称作可重入函数，反之为不可重入函数。

这通常涉及到多线程或者中断处理的情况。

如果函数可重入，则一定线程安全。

## 互斥锁
> 乐观锁，悲观锁，自旋锁，

>读写锁

加锁会导致线程串行运行，所以粒度越低越好。也就是临界区的代码越少越好。

加锁后，依旧会被切换。但是因为只有一个线程持有锁，切到其他线程后无法向下进行。知道切回持有锁的线程执行。

创建锁：互斥锁是原生线程库提供的变量类型。
```C
pthread_mutex_t 变量名;
```

初始化锁
```C
#include <pthread.h>

int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);
pthread_mutex_t mutex = PTHREAD_COND_INITIALIZER;//全局
```


加锁:加锁后，只有一个执行流（拿到锁的那个）能接着向下执行代码
```C
#include <pthread.h>

int pthread_mutex_lock(pthread_mutex_t *mutex);
```

加锁：非阻塞式申请锁，如果拿到锁，向下执行，每拿到锁，则报错返回
```C
#include <pthread.h>

int pthread_mutex_trylock(pthread_mutex_t *mutex);
```

解锁：解锁后，所有执行流就可以争抢锁（也有可能被释放锁的进程重新抢到）
```C
#include <pthread.h>

int pthread_mutex_unlock(pthread_mutex_t *mutex);
```

销毁锁：
```C
#include <pthread.h>

int pthread_mutex_destroy(pthread_mutex_t *mutex);
```

### 互斥锁的原理

线程的上下文是私有的。锁的本质是一个大于0的值。

线程加锁时，线程将0与锁值交换，存入线程的上下文。

此时如果切换到其他线程，因为锁的值已经被换为0，交换后也是0。

向下执行时进行判断，如果线程上下文中的锁值大于0，则向下执行。否则挂起等待。此时保证了只有一个线程能向下执行。

当释放锁时，拿到锁值的线程，再次与锁变量的值交换。此时锁变量的值大于0。其他线程切入CPU时，就能交换到大于0的锁值，向下执行代码。

因为交换锁值与线程上下文值的汇编代码只有一句，所以是原子的，也就是加锁解锁操作是原子的，也就是安全的。

### 线程安全
常见线程不安全情况：
1. 不保护共享变量的函数
2. 状态随着调用而发生变化的函数
3. 返回指向静态变量指针的函数
4. 调用线程不安全函数的函数

线程安全函数不一定可重入，反而可能触发死锁。

## 死锁

线程执行代码时，可能需要多把锁。

线程a，需要先申请锁1，再申请锁2才能向下执行代码。

线程b，需要先申请锁2，再申请锁1才能向下执行代码。

代码执行时，线程a申请到了锁1，线程b申请到了锁2.此时都要去申请第二把锁，但是都已经被对方申请，于是都被堵塞。此时代码无法向下进行。

这就称作死锁。

> 一把锁也可能产生死锁
> 当一个线程已经持有锁，但是有申请同一把锁，此时无法申请到，被挂起，无法被唤醒。

### 死锁产生的四个必要条件

互斥：一个资源只能被一个执行流使用
请求与保持：一个执行流因请求资源而堵塞时，对已经获得的资源保持不放
不剥夺：一个执行流已获得的资源，再未使用完之前，不能强行剥夺
循环等待：若干执行流之间形成一种头尾相接的循环等待资源的关系

## 特殊锁

### 读写锁



### 自旋锁