线程在进程内部执行，是OS调度的基本单位。

我们只创建PCB，并将新的PCB(task_struct)指向同样的mm_strcut(进程虚拟地址管理结构体)

通过一定手段，将当前进程的资源，以一定方式划分给指向同一个mm_strcut的不同的task_strcut

此时这每个task_strcut叫做一个线程。

>OS调度资源以PCB位单位调度，进程和线程都有独立的PCB，所以都可以称作OS调度的基本单位。不过线程调度更细。

在内核层面上，OS即CPU不需要区分进程和线程。只关心PCB。通过复用的方式，以同一种方式管理线程和进程。所以linux下没有真正意义上的线程，他通过PCB模拟线程。

linux的进程统称位轻量级进程。因为没有真正意义上的线程。所以linux不能提供线程相关的接口，只能提供轻量级进程的接口。但是在用户层面上，linux实现了多线程方案--pthread库（原生线程库）

在创建进程时，OS创建其PCB并分配资源。当创建线程时，也创建PCB，但不再向OS申请资源，而是向进程申请资源。

多个线程对应多个执行流。每有一个线程，表明进程有一个执行流。（进程至少有一个执行流）

线程没有父子关系，只有主线程和新线程。

同属于一个进程的线程pid相同，但LWP不同，LWP是轻量进程id，如果一个线程的LWP和PID值相同，则为主线程。主线程退出时，进程所属全部线程退出。

> 堆区，共享区都被所有线程共享，但是可以认为是私有的。因为只有一个线程能拿到资源地址。

线程ID，寄存器（上下文），栈是私有的

>每个线程有独立的栈，虽然其他线程可以通过某种方式拿到其他线程的栈。但是我们认为他是私有的


为什么线程切换成本低？

页表和内存地址不需要切换

cpu会通过缓存的方式，对内存的代码和数据，根据局部性原理，预读到cpu内部，进程切换时，会切换这部分缓存，但线程切换不会切换缓存。

