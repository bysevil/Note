关于线程，每个OS的具体实现并不相同，我们只讨论linux
## 线程与进程
线程在进程内部执行，是OS调度的基本单位。

我们只创建PCB，并将新的PCB(task_struct)指向同样的mm_strcut(进程虚拟地址管理结构体)

通过一定手段，将当前进程的资源，以一定方式划分给指向同一个mm_strcut的不同的task_strcut

此时这每个task_strcut叫做一个线程。

>OS调度资源以PCB位单位调度，进程和线程都有独立的PCB，所以都可以称作OS调度的基本单位。不过线程调度更细。

在内核层面上，OS即CPU不需要区分进程和线程。只关心PCB。通过复用的方式，以同一种方式管理线程和进程。所以linux下没有真正意义上的线程，他通过PCB模拟线程。

linux的进程统称位轻量级进程。因为没有真正意义上的线程。所以linux不能提供线程相关的接口，只能提供轻量级进程的接口。但是在用户层面上，linux实现了多线程方案--pthread库（原生线程库）

在创建进程时，OS创建其PCB并分配资源。当创建线程时，也创建PCB，但不再向OS申请资源，而是向进程申请资源。

## 线程与线程
多个线程对应多个执行流。每有一个线程，表明进程有一个执行流。（进程至少有一个执行流）

线程没有父子关系，只有主线程和新线程。

同属于一个进程的线程pid相同，但LWP不同，LWP是轻量进程id，如果一个线程的LWP和PID值相同，则为主线程。主线程退出时，进程所属全部线程退出。

任何线程出现错误时，整个进程结束。

> 堆区，共享区都被所有线程共享，但是可以认为是私有的。因为只有一个线程能拿到资源地址。

线程ID，寄存器（上下文），栈，errno，信号屏蔽字是私有的

>每个线程有独立的栈，虽然其他线程可以通过某种方式拿到其他线程的栈。但是我们认为他是私有的
## 线程的优点

1. 切换成本低
页表和内存地址不需要切换

cpu会通过缓存的方式，对内存的代码和数据，根据局部性原理，预读到cpu内部，进程切换时，会切换这部分缓存，但线程切换不会切换缓存。

## 线程的缺点

性能损失：在线程数多于CPU核数时，容易造成计算密集型程序性能损失

健壮性损失：线程之间缺乏保护，容易相互影响造成预料之外的结果。（一般来说代码能力足够完全可以避免这个问题）

缺乏访问控制：多个线程可以同时访问同一片资源

编程难度提高：多线程程序难调试

### 优化防止

在C语言中，`volatile` 关键字通常用于防止编译器对某些变量的优化。当一个变量被声明为 `volatile` 类型时，编译器不会对其进行优化，以确保每次对该变量的访问都会从内存中读取或写入，而不是使用缓存或寄存器中的值。

例如，当一个变量可能被多个执行流修改时，使用 `volatile` 可以确保每次访问都会得到最新的值，而不会使用缓存中的旧值。
