## 冯洛伊曼体系结构
存储器:内存
控制器:
运算器：数学运算，逻辑运算。
输入设备：键盘，摄像头，鼠标，麦克风等
输出设备：显示器，音响等。

中央处理器（CPU）：包含控制器和运算器。

### 为什么要有内存

当存储设备和CPU交互时,因为木桶原理,其速度受限于最低速度的存储设备。

而如果都要使用存取速度快的存储设备，则需要大量成本。

这时候加入内存，将我们要处理的信息提前加载入内存，此时CPU存写数据的速度只受限于内存，我们只需要采购能够高速存取的内存设备，大大降低了成本。

### 什么是IO

CPU从内存中存取数据。站在数据的角度，CPU不和外设直接交互

CPU要处理数据，都是先将外设中的数据加载进内存然后读取，站在数据的角度,外设只直接和内存交互。

内存和外设交换数据的过程称作IO。

数据加载入内存的过程为I（input），数据从内存输出到外设的过程称作O（output）

## 操作系统

操作系统也是一个软件，它对计算机的软件和硬件做管理。

它给用户提供一个稳定，安全，简单的执行环境。

操作系统和软硬件可以不直接交互。只要拿到软硬件的数据就可以使用相关的软件进行管理。本质上是对数据的管理。

操作系统通过驱动来获取硬件的数据并进行管理。通过进程来获取软件的数据并进行管理。

> LInux内核是用C语言写的，它先将各个需要管理的对象描述为一个结构体（struct），通过组织（使用链表或者其他高效的数据结构）这些结构体来管理相应的对象。

### 系统调用和库函数

在开发角度，操作系统对外会表现为一个整体，但是会暴露自己的部分接口，供上层开发使用，这部分由操作系统提供的接口，叫做系统调用。

系统调用在使用上，功能比较基础，对用户的要求相对也比较高，所以，有心的开发者可以对部分系统调用进行适度封装，从而形成库，有了库，就很有利于更上层用户或者开发者进行二次开发。

## 进程

启动一个软件就是启动了一个进程。

> 启动软件时,要将软件加载入内存，此时操作系统创建一个进程来调度这个软件。

> 在Linux下,命令本身也是程序,运行命令时也创建了一个进程。

进程 = 软件对应的代码和数据 + 描述这个软件的PCB结构体

### PCB

PCB全称为process control block

每创建一个进程,操作系统会创建一个PCB的结构体,这个结构体描述了此进程的所有属性。

PCB结构体的具体名称在比特系统中并不相同,在Linux下,这个结构体的名称为`tast_struct`

tast_strcut的属性:
- 标示符: 描述本进程的唯一标示符，用来区别其他进程。
- 状态: 任务状态，退出代码，退出信号等。
- 优先级: 相对于其他进程的优先级。
- 程序计数器: 程序中即将被执行的下一条指令的地址。
- 内存指针: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针上下文数据: 进程执行时处理器的寄存器中的数据\[休学例子，要加图CPU，寄存器\]。
- I／O状态信息: 包括显示的I/O请求,分配给进程的I／O设备和被进程使用的文件列表
- 记账信息: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。
- 其他信息

### 查看进程信息

可以在内核源代码里找到它。所有运行在系统里的进程都以task_struct链表的形式存在内核里。

每个进程都有一个PID。在C语言中,可以通过`gitpid()`来获取本程序的PID;

查看进程进程的信息可以通过`/proc`系统文件夹查看如：要获取PID为1的进程信息，你需要查看`/proc/1`这个文件夹。

大多数进程信息同样可以使用top和ps这些用户级工具来获取

即时监视进程信息(相当于widows下的任务管理器)：
```shell
top
```
打印当前进程信息（常用）：
```shell
ps ajx
```
- a:显示所有进程
- x:改变显示的格式

> 文件夹是动态创建的,每多一个进程， /proc下就会多一个以此进程的pid为名的文件夹,保存这个进程的信息,进程结束时,文件夹销毁。

### 进程优先级
PRI为进程的优先级，PRI值越小，优先级越高。

NI（nice）是优先级的修正值，用来修改PRI的值，取值为\[-20，19\]。

> new PRI = oldPRI + nice；

**修改优先级：**进入top后按下r，输入进程PID后输入nice值，默认情况下，oldPRI = 80；

### 进程的特性
- 竞争性: 系统进程数目众多，而CPU资源只有少量，甚至1个，所以进程之间是具有竞争属性的。为了高效完成任务，更合理竞争相关资源，便具有了优先级
- 独立性: 多进程运行，需要独享各种资源，多进程运行期间互不干扰
- 并行: 多个进程在多个CPU下同时运行，这称之为并行
- 并发: 多个进程在一个CPU下采用进程切换的方式，在一段时间之内，让多个进程都得以推进，称之为并发

>一个CPU同时只能运行一个进程。CPU调度代码的时候是以并发的形式调度的；
> 一个进程进入CPU后运行一个时间片的时间，然后切换到下一个进程，如果进程结束，则退出运行态。否则继续在运行队列中排队。
> 这也就有了抢占与出让的概念，当遇到优先级高的进程，会直接抢占原来的运行队列，进行插队。
### 进程的继承关系
进程间是有继承关系的，每个进程的PPID标识了其父进程的PID

在C语言中，可以通过`gitppid()`函数来获取本程序的PPID

每次登录云服务器，都会创建一个新的base进程，这个进程是你在此次登录中启动的所有进程的父进程。

C语言可以通过`fork()`来创建一个子进程。

fork()创建成功时给父进程返回子进程的pid,给子进程返回0。创建失败时返回-1。

也就是说fork有两个返回值，这是因为fork创建了一个子进程，现在同一个程序使用同一个代码（使用写时拷贝），但是数据分开保存。
```C
pid_t pid = fork()
printf("hello C\n");
```
> 在上面的程序中,hello C被打印两次,因为创建了一个子进程,父子进程代码共享,都运行了一次`printf("hello C\n");`

一般来说,fork后需要用if分流:
```C
pid_t pid = fork()
if(pid == -1){
	printf("fork fail");
	exit();
}else if(pid == 0){
	printf("hello subprocess");
}else{
	printf("hello parent process");
}
```

### 进程的状态

tast_struct被组织为队列。每个资源都有一个队列。CPU队列，显卡队列等。当进程需要调用某种资源时，就会加入相应的队列。

CPU队列称为运行队列。

**操作系统理论中的进程状态：**

- 运行态（R running）：进程在运行队列中。
- 阻塞：等待非CPU资源就绪。可能是资源被其他进程占用，或是等待相应资源返回值。
- 挂起：当内存不足的时候，将阻塞或是其他原因导致长时间闲置的进程暂时置换到磁盘中。

**linux的进程具有的实际状态：**
- 运行状态（R running）：进程在运行队列中。
- 睡眠状态（S sleeping）：可中断睡眠状态，也就是可以使得其进入运行态。
- 磁盘睡眠（D disk sleep）：磁盘睡眠，深度睡眠，不可以被被动唤醒。
- 暂停状态（T stopping）：暂停状态，调试状态（程序被调试时处于次状态）。
- （T tracing stop）：
- 僵尸状态（Z zombie）：进程已经退出，但正在被OS或父进程检测，不允许被释放。
- 终止状态（X dead）：进程运行结束，可以被销毁。此状态非常短暂，几乎无法查看。
> 进程分为前台进程和后台进程，后台进程不影响命令行交互。状态后使用+标识为前台进程，无标识为后台状态。

Linux2.6内核中描述进程状态的数组：
```C
static const char* tast_state_array[] = {
	"R (running)" /* 0 */
	"S (sleeping)",/* 1 */
	"D (disk sleep)",/* 2 */
	"T (stopping)",/* 4 */
	"T (tracing stop)",/* 8 */
	"Z (zombie)",/* 16 */
	"X (dead)"/* 32 */
}
```

使得进程终止
```shell
kill -9 PID
```

### 僵尸进程

#### 孤儿进程
如果子进程还没退出,而父进程退出了,此时子进程的父进程会变为init(被init领养);

init进程的PID为1，是系统本身；

### 上下文数据

进程存入寄存器中的临时数据，称作上下文数据。

**上下文数据绝对不可以被丢弃**

当进程从CPU中被切换下来的时候，需要带走自己的上下文数据，以便下次进入CPU的时候继续按照之前的状态向下执行。如同没有中断过一样。
### 进程地址空间
从高到低为：

- 栈区
- 
- 堆区
- 未初始化全局区
- 已初始化全局数据区
- 代码区

堆区向下增长，栈区向下增长。其他区空间固定；
环境变量(environment variables)一般是指在操作系统中用来指定操作系统运行环境的一些参数

我们在编写C/C++代码的时候，在链接的时候，从来不知道我们的所链接的动态静态库在哪里，但是照样可以链接成功，生成可执行程序，原因就是有相关环境变量帮助编译器进行查找。

环境变量通常具有某些特殊用途，具有全局性。

## 环境变量
### 操作环境变量

- env：查看所有的环境变量
- echo: 显示某个环境变量值
- export: 设置一个新的环境变量
- unset: 清除环境变量
- set ：显示本地定义的shell变量和环境变量

> 命令行改变的环境变量只在当次登录有效，它是和进程挂钩的，只是改变了当前登录进程的环境变量值。

### 常见环境变量

- PATH : 指定命令的搜索路径
- HOME : 指定用户的主工作目录(即用户登陆到Linux系统中时,默认的目录)
- SHELL : 当前Shell,它的值通常是/bin/bash。

## main函数的参数
main函数可以接收三个参数；
```c
int main(int argc,char* argv[]，char* env[]){
	return 0;
}
```

argc 指的是main接受的命令行参数的数目
argv\[\] 以字符串形式储存每个命令行参数
> argc的最小值是1，不是0，因为程序最起码接受一个参数argv[0] ，它的值总是程序的名称。

env是以字符串形式存储的每个环境变量的值；

可以使用`getenv(环境变量名)`获取环境变量的值；

进程的环境变量信息是从父进程那里获取来的。