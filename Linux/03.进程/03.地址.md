程序中所有有关地址的信息都是虚拟地址（或称线性地址）而非物理地址。操作系统为保证系统的安全性和稳定性,不允许直接访问物理地址；

对每个进程都有一个虚拟的地址空间。其本质是一个结构体，操作系统通过页表将虚拟地址映射为物理地址来拿到或者存入数据。

如果虚拟地址非法，则无法进行映射，保护了物理地址。
## 进程地址空间分布
从高到低为：

- 栈区
- 共享区
- 堆区
- 未初始化全局区
- 已初始化全局数据区
- 代码区

堆区向下增长，栈区向下增长。其他区空间固定；

在linux下，进程的地址空间取值范围0x 0000 0000 ~ 0x FFFF FFFF

其中：
- 0~3G为用户空间
- 3~4G为内核空间

## 虚拟地址空间的本质

地址空间是一种内核数据结构(struct mm_strcut)，它里面至少有各个区域的划分。

区域划分即为存储其起始物理地址和结束物理地址。

## 父子进程地址相同

在使用fork创建子进程后，其已经有的变量的虚拟地址相同。

此时如果子进程尝试修改，操作系统回来保证地址的独立性，会另外划分一片空间给子进程，并修改页表的映射关系，如果必要的话，会将父进程物理空间的内容拷贝到子进程的物理地址空间。此时虽然父子进程中的变量的虚拟地址相同，但是使用的是两片物理地址。


地址空间不仅是OS要遵守的，编译器也要遵守。编译器编译代码的时候，就已经形成了各个区域，采用和Linux内核中一样的编码方式。程序编译结束后，就已经具有虚拟地址了；

当程序加载到内存的时候，每行代码，每个变量都有了一个物理地址。（当CPU读到指令的时候，指令内部也有地址（虚拟地址））

### 为什么要有虚拟地址

1. 保护物理地质
2. 将乱序的物理地址中的数据有序化
3. 进程独立性
每个进程都认为自己独占内存，甚至不知道其他进程存在，不受其他进程干扰。