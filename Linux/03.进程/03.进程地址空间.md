>以32位系统和程序为例，64位操作和管理方法相同，不过操作的基本单位和总空间大小更大。

程序中所有有关地址的信息都是虚拟地址（或称线性地址）而非物理地址。操作系统为保证系统的安全性和稳定性,不允许直接访问物理地址；

对每个进程都有一个虚拟的地址空间。其本质是一个结构体，操作系统通过==页表==将虚拟地址映射为物理地址来拿到或者存入数据。

如果虚拟地址非法，则无法进行映射，保护了物理地址。
## 页帧与页框
进程地址空间以4kb划分，可执行程序编译时，也被划分为4kb单位，每个单位被称作一个页帧。

而在物理内存中，也划分为4kb大小进行管理，每个单位称作一个页框。

> 操作系统通过page结构体管理每个页框

执行程序，本质是将页帧装进页框，所以IO的基本单位为4KB。

当执行程序时，发现下一句要执行的指令所在的页帧还没加载到页框中，将会发生缺页中断，此时操作系统将页帧加载入页框，再映射到页表，让用户继续访问。

## 进程地址空间分布
从高到低为：
- 系统区
- 栈区
- 共享区
- 堆区
- 未初始化全局区
- 已初始化全局数据区
- 代码区

堆区向下增长，栈区向下增长。其他区空间固定；

在linux下，进程的地址空间取值范围0x 0000 0000 ~ 0x FFFF FFFF

其中：
- 0~3G为用户空间
- 3~4G为内核空间
### 堆区空间

malloc在系统底层会调用brk函数，来申请堆区空间。堆区空间在物理空间上不连续。

申请空间时，操作系统会创建vm_area_struct结构体，来管理申请的空间。

它具有以下成员：
- unsigned long vm_start：此空间的起始
- unsigned long vm_end：此空间的结束
- struct vm_area_struct* vm_prev,vm_next：下一个和上一个结构体
### 页表

页表并表示一张表，而是多张表。

操作系统将内存物理地址前10位保存于一级页表，后10位保存于2级页表。每个页表共构建2^10个虚拟地址到物理地址的映射关系。

一级页表称作页目录，我们通过1级页表找到对应的2级页表。

通过二级页表，我们就找到了目标的页起始地址。

通过后12位，知道数据的页内偏移量。通过页起始地址和页内偏移，我们找到实际的物理地址。

## 虚拟地址空间的本质

地址空间是一种内核数据结构(mm_strcut)，它里面至少有各个区域的划分。

区域划分即为存储其起始物理地址和结束物理地址。

## 父子进程地址

在使用fork创建子进程后，其已经有的变量的虚拟地址相同。

此时如果子进程尝试修改，操作系统会来保证地址的独立性，会另外划分一片空间给子进程，并修改页表的映射关系，如果必要的话，会将父进程物理空间的内容拷贝到子进程的物理地址空间。此时虽然父子进程中的变量的虚拟地址相同，但是使用的是两片物理地址。

地址空间不仅是OS要遵守的，编译器也要遵守。编译器编译代码的时候，就已经形成了各个区域，采用和Linux内核中一样的编码方式。程序编译结束后，就已经具有虚拟地址了；

当程序加载到内存的时候，每行代码，每个变量都有了一个物理地址。（当CPU读到指令的时候，指令内部也有地址（虚拟地址））

### 为什么要有虚拟地址

1. 保护物理地质
2. 将乱序的物理地址中的数据有序化
3. 进程独立性
每个进程都认为自己独占内存，甚至不知道其他进程存在，不受其他进程干扰。

## 写时拷贝

当创建子进程时，不会直接创建子进程的地址空间和页表。此时父子进程使用同一片空间，且这片空间是只读的。

当进程进行了数据修改时，才会创建子进程的地址空间，并将父子进程数据分离，并取消其只读性。

