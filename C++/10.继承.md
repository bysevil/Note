继承是一种类层次的代码复用，如果多个类有同样的特征，可以把他们的共同特征提取出来，放在另一个类里，这个类称作父类或者基类，其它有共同特征的类可以继承这个类来获得这些共同特征。

```c++
class 父类
{···};

class 子类名 : 继承方式 父类名
{···}；
```

## 继承方式

> 继承方式可以省略，子类为class默认私有继承，为struct时默认公有继承。但一般建议写明

继承有3种：
- public：不改变权限继承
- protected：继承后都变为保护成员
- private：继承后都变为私有成员

> 继承只继承基类的保护和公有成员，并通过继承方式来决定其在基类的权限。
> 
> 继承不会继承基类的私有成员，也不会继承友元关系。
> 
>实际一般使用公有继承
>
>静态成员变量也会被继承，因为静态成员变量属于整个类，这个类包括子类和父类，所以子类使用的也是父类的静态成员变量，不会像普通继承那样，在子类中隐式生成父类的成员。


## 重定义

子类和父类中有同名成员（函数和变量都可以），子类会屏蔽对父类成员的直接访问。这叫做隐藏，或者重定义。

>在父类和子类中，只需要函数名相同就可以构成隐藏，不需要参数不同。
>
>也就是说，在子类中访问这个同名成员时，只会访问子类的成员。只有加上访问限定符，才会访问父类的成员。
>
> 即也是说，子类和父类不在一个作用域。且父类的作用域包含了子类的作用域。
>
>一般不要进行重定义

## 派生类的默认成员函数

派生类不显式定义默认成员函数时，会自动调用父类的默认成员函数来应用给自己。

派生类显式定义默认成员函数时，无法直接操作继承来的成员变量，需要显示调用父类默认成员函数来处理继承来的成员变量，然后调用自己的默认成员函数来处理自己独有的成员变量。

>析构函数不允许显式调用父类的，子类析构函数始终会在调用子类析构后自动调用父类的析构函数。
>
> 直接调用父类析构函数会报错，因为析构函数会被编译器自动重命名为 destructor，父类和子类都被重命名为同一个函数名，构成了重定义。所以C++编译器会自动调用父类的析构函数，此时加访问限定符可以访问父类的析构函数，但是会调用两次父类的析构函数，因为已经被隐式自动调用了一次。

## 赋值兼容

可以将子类对象直接赋值给父类，指向子类对象的指针也可以赋值给指向父类对象的指针
```c++
父类对象 = 子类对象;
父类指针 = 子类指针;
```

> 这会发生切片，将子类中继承自父类的成员切割出来，将其值反向赋值给父类。
> 
> 这个过程中没有隐式类型转换，是直接切割
> 
>父类对象无法赋值给子类，指向父类对象的指针
## 多继承

一个父类可以有多个子类，一个子类也可以有多个父类
```c++
class 子类 : 继承方式 父类1, 继承方式 父类2
{}
```

这种灵活性导致了菱形继承的出现，也就是一个父类，其有两个子类，这两个子类，又有一个共同的子类。

这就导致了共同子类继承了其两个父类的成员变量，二两个父类又是同时继承自其共同父类的，这就导致了：
1. 冗余性：同时继承了两个同名变量，而且这两个同名变量可能具有相同数据。
2. 二义性：使用变量时不明确使用的是哪个父类继承来的变量，必须添加访问限定符。
### 虚继承

虚继承解决了多继承的数据冗余和二义性

```c++
class 子类 ： vartual 继承方式 父类
{}
```
> 虚继承在菱形继承中，只需要给有共同父类的两个子类使用

在菱形继承中，共同子类会有两份共同父类的成员变量的值，分别存储在其继承的两个父类中，为了避免这种情况，虚继承会让共同子类中只有一份成员变量的值，存储在子类空间的最后，而在其本来该在的位置中存储一个指针，这个指针指向的数据为空，其下一个位置存储父类成员变量相对于虚继承生成的一份成员变量的偏移量。

> 也就是说，虚继承只多了两个指针的空间，用来指向存储偏移量的数据位置的指针，而使得两份数据只需要存储一份，然后通过偏移量寻找就行。

为什么存储偏移量：因为赋值兼容，存储绝对地址，当子类对象以赋值兼容的形式给父类时，如果访问绝对位置，访问的还是子类对象的值，而存储偏移量，在赋值兼容后，指向的就是父类对象的值了。

## 组合

组合和继承都是内部类的复用方式

```C++
class A
{}

class B
{
private:
	A _objA;
}
```
这种称作B组合A

> 这种的优点在于耦合度低，A中发生了修改很难影响到B。在为继承关系时，A任何修改都容易对B造成改变。