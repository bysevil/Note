## 命名空间
在C语言中，同一作用域中不能定义同名变量。

但是涉及全局变量和函数时，你无法保证多个文件的全局变量和函数名字都不相同。特别是在多人协作时，这个问题尤为明显。

此时，C++使用了命名空间来解决这个问题，不同命名空间的变量和函数可以重名；

命名空间只影响查找规则，使用变量时，默认会去局部找，然后去找全局，除非指定，否则不会去找命名空间的内容。但是命名空间不影响生命周期，只影响使用。

> - C++标准库中的内容都在命名空间`std`中
### 定义命名空间
```C++
namespace 空间名{
	···
}
```
> 多个文件定义同一命名空间，会被认为是同一个命名空间而被合并。
> 
> 命名空间可以嵌套
### 访问命名空间
#### 域访问限定符`::`
使用指定命名空间的内容
```C++
空间名::内容名
```
>- 当空间名为空时，表示全局域
>```C++
>::变量名
>```
>- 访问嵌套空间需要多个域访问限定符
#### 全局展开
如果你的代码不涉及命名冲突，这时候你访问命名空间中的变量和函数等每次都需要使用域访问限定符，十分繁琐。

这时候你可以指定命名空间全局展开，此时你访问这个空间内的内容就不需要域访问限定符了。
```c++
using namespace 空间名;
```
> 改变了查找规则，先在局部，然后全局，然后找展开的命名空间。而非全局找不到就认为内容未定义。
> 一般情况下，不建议全局展开
#### 部分展开
全局展开及其容易导致名称冲突，但是我们又不想每次使用时使用域访问限定符。此时可以部分展开。

部分展开只展开指定内容，使用部分展开的内容时不需要域访问限定符。
```c++
using 空间名::内容名
```
## 输入和输出
### 输出

C++一般使用流插入操作符，将输出插入到标准输出流的方式进行输出
```C++
cout << "hello world";
```
流插入操作符支持连续插入
```C++
cout << "hello" << "world";
```
插入句尾回车
```C++
cout << "hello world" << endl;
```

### 输入

使用流提取操作符从标准输入流获取输入
```C++
cin >> val1 >> val2;
```

> 这种方式会自动获取输入的类型;
## 缺省参数（默认参数）

我们给函数传参的时候，需要一一对应。

我们可以给参数一个默认值，在没有传递参数的时候，使用这个默认值。

```c++
type fun(type val= 默认值){
	···
}
```

> 如果所有参数都是缺省参数，则称作全缺省
### 半缺省
部分参数缺省，部分不缺省称为半缺省

半缺省时，缺省参数必需从右往左连续缺省
 ```c++
//正确
void fun(int a,int b = 0,int c = 0);

//错误
void fun(int a = 0,int b);
```
## 函数重载

如果在同一作用域有两个同名函数，但是参数表不同。则称为函数重载。
```c++
int add(int,int);
double add(double,double);
```
> 函数重载时返回值可以不同，但是只有返回值不同不能构成重载

> 重载主要看的是形参的类型和类型的顺序
> ```c++
> int add(int a,int b);
> int add(int b,int a);
>```
>不算是函数重载
### 函数重载的原理
函数重载本质上时因为编译器对函数名进行了修饰，所以在编译器看来是不同名的函数

在VS下，
```C++
int add(int,int);
double add(double,double);
int funtion(int);
```
会被修饰为
```C++
_Z3addii;
_Z3adddd;
_Z7funtioni;
```
即 `_Z` + `函数名长度` + `形参表每个参数类型的首字母`;

> 每个编译器的修饰方式不同

## 引用
引用是给已经存在的变量取一个别名，两个变量名使用同一片内存空间，不会开辟新空间。

改变其中一个的值另一个的值也会改变，因为两个变量名实际上使用的是同一个内存空间；

```C++
变量类型& 引用名 = 变量名; 
```
 > - 引用必须和变量是一个类型
 > - 一块空间可以有多个别名
 > 	- 对别名也可以取别名 
### 引用传参
引用传参的作用是：形参是实参的别名而非拷贝，所以改变形参值也会改变实参值;
```C++
int add(int& a,int& b){
	···
}
```