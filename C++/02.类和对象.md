## 定义类和成员函数

C++将结构体升级成了类，所以你可以在结构体里定义函数。

但是C++不建议使用struct关键字来定义类，而是使用class关键字。

```cpp
class 类名{···};
```

> 类和对象的三大特点：封装，继承，多态
>
> 类中依旧存在内存对齐，当类中没有成员变量只有成员函数时，其大小为1字节。这一个字节不存储有效数据，只用来表示对象被实例化。

你可以在类外定义指定类的成员函数。

```cpp
class 类名{···};
type 类名::成员函数名(){}
```

> 虽然是在类外定义的成员函数，但是其作用域和生命周期并没有改变，依旧相当于在类的内部进行了定义。

## 成员函数和成员

在类中定义的函数称作类**成员函数**，变量称作**成员变量**。

成员变量在对象中，成员函数不在对象中。

因为每个对象的成员变量是不同的，但是同一个类的不同对象调用的是一样的函数。所以每个对象调用成员函数是一样的，放到一个公共区域（代码段）。

> 因为成员函数不在对象中，而是在代码段中。所以如果成员函数中没有使用类成员变量，那么即使是通过空指针调用成员函数，也能正常执行程序。因为你实际上没有访问空指针。而如果成员函数中使用了成员变量，那么你就需要访问对象的地址，此时发生了空指针的解引用，报错。
>
> C++11支持给成员变量给缺省值,这个缺省值实际上是通过构造函数的缺省参数实现的

### 访问类成员和成员函数

使用 `.`来访问类的成员和成员函数

```cpp
类名.成员函数名(实参表);
类名.成员名
```

> 只有在类外访问其公共的成员和成员函数时才需要这样写，私有成员和成员函数只有在类的内部才能访问，也不需要 `.`操作符，直接使用成员或成员函数名访问即可

### this指针

this指针指代对象自己，通过哪个对象访问的类，this就指向那个对象。当同一个类有不同对象时，this用来区分每个对象,确认是哪个对象调用了类的非静态成员函数，或是确认应当使用哪个对象的得静态成员变量。this在类创建时被编译器定义，不需要手动定义。

this存在于栈中，是每个类的非静态成员函数隐含的参数，只能在非静态成员函数中使用。（VS中是通过ecx寄存器）

this是const的，不能被修改。

> 事实上，如果在非静态成员函数中使用非静态成员变量，都隐含了this，因为每个对象的非静态成员变量的值是不同的。但是一般不需要显式指明。
>
> ```cpp
> this->成员变量 = 值;
> 成员变量 = 值;
> ```
>
> 上面两种语法作用相同

### static

#### static成员变量

static声明静态成员，静态成员属于整个类，而非单独属于某个对象。

普通的成员变量，在每个对象中的值互不影响，但是static成员变量是 此类的所有对象共有的，在某个对象中修改了static成员的值，其他对象中的值也会被修改。

```cpp
class 类名{
 static 变量类型 变量名;
}
```

你可以通过类去访问static成员变量。也可以通过其对象去访问

```cpp
类名::变量名;
对象名.变量名;
对象指针->变量名;
```

> static修饰的成员变量储存在静态区

```cpp
类型 类名::变量名 = 值;
```

> static修饰的成员变量不能给缺省值，只能这样初始化

#### static成员函数

ststic成员函数属于类，而非单独属于整个对象。

static成员函数没有隐含的this指针，所以无法访问普通成员变量。

```cpp
class 类名
 static 类名 成员函数(){
  ···
 }
}
```

你可以通过类去访问static成员函数。也可以通过其对象去访问

```cpp
类名::成员函数();
对象名.成员函数();
对象指针->成员函数();
```

## 类对象的实例化

类在定义和声明时并不会开辟空间，只有在实例化相应的类对象时才会开空间。（相当于建立结构体对象时才会开辟结构体空间)

```cpp
类名 对象名;
类名 对象名(初始化列表);
```

### 匿名对象

匿名对象没有名字，生命周期只在当前行。

```cpp
类名();
```
可以延长匿名对象的生命周期
```cpp
const 类名& 对象 = 类名();
```
> 即使用一个const的引用来给匿名对象起别名

有时候不想创建对象但想要一次性的调用类成员函数，便可以使用匿名对象

```cpp
//打印成员函数返回值
cout << 类名().成员函数() <<endl;
//返回一个类对象的函数
类名 函数(){
 return 类名();
}
```

## 访问限定

我们可以限定变量和成员函数的权限

- public公有
- private私有
- protected保护

公有变量和成员函数可以在类外访问，私有和保护的变量和成员函数只能在类中访问.

> class定义的类的成员函数默认为private，struct定义的类的成员函数默认为public（为了和C兼容）
>
> 但是我们依旧建议写明其权限，即使和默认的权限一样
>
> 访问限定符只在编译中有用，映射到内存后并无区别

```cpp
class类名{
private:
 私有变量和成员函数
public:
 公有变量和成员函数
}
```

### 封装

封装就是隐藏对象的属性和实现细节，只通过接口来调用它。而不追究其内部实现。

C++控制数据和成员函数的访问方式，可以在类外访问的为公有，不可以的为私有。

使这得数据和成员函数的访问更安全，更不容易出错。

### 友元
友元能够突破封装的限制，使得可以在类的外部访问类的成员。

友元函数是普通函数，但是在类中进行友元声明后，函数就可以访问类的私有成员。
```cpp
class 类名{
	friend 返回值类型 函数名(参数表);
}

返回值类型 函数名(){
	···
}
```
> 一般不建议使用友元，他破坏了封装

类也可以是类的友元
```cpp
class 类1{
	friend class 类2
}

class 类2{
	···
}
```
> 类2是类1的友元，所以类2可以访问类1的私有成员，但是类1不能访问类2的私有成员。

> 友元不能传递，a是b的友元，c是a的友元，但是c不是b的友元

> 友元不能继承

### 内部类
如果一个类中定义一个类，里面的那个类称作外面的类的内部类。

内部类是外部类的友元，外部内不是内部类的友元。

```cpp
class 外部类{
	class 内部类{
		···
	}
}
```

虽然定义在外部类里面，但是跟外部类的空间是独立的。只是受类域的限制。

```cpp
外部类::内部类 内部类对象;
```

## const成员函数

当const修饰成员函数时，其实是修饰隐含的this指针，作用是使得在成员函数中不能修改所有的成员变量。

```cpp
class 类名{
 成员函数() const{
  ···
 }
}
```

> 如果我们在实例化对象时使用const修饰对象，这时候对象时不能修改的，但是this指针默认是可以修改的，此时调用类中的成员函数，会出现权限放大而报错。此时休要修饰this指针为const，但是this是被编译器隐式声明的参数，所以我们只能通过给成员函数加const间接给this加const。

## 编译器的优化

编译器不会跨语句优化，但是在同一个语句进行非引用传参和非引用返回时编译器会进行优化

> 尽量不要影响编译器优化，在能优化的地方不要分割为两个语句导致编译器不进行优化。
> 1.  接收返回值对象，尽量拷贝构造方式接收，不要赋值接收。
> 2. 函数中返回对象时，尽量返回匿名对象。
> 3. 尽量使用`const &`传参

```cpp
fun(类名(参数));
```

>  fun函数的参数是一个类对象，因为是传值传参，所以发生了拷贝。调用了拷贝构造函数。
>  其参数是一个新创建的匿名对象，调用了构造函数。
>  编译器把构造+拷贝构造优化为了直接在fun中构造。

```cpp
返回类对象 fun(){
	return 类对象;
}

类名 对象 = fun();
```

> 正常情况下，返回类对象会创建临时对象，发生一次拷贝。然后将临时对象返回给对象，此时又发生拷贝。这个对象是一个新对象，发生了构造。
> 编译器会将两次拷贝构造和一次构造优化为一次构造。
