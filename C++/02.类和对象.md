## 定义类和成员函数

C++将结构体升级成了类，所以你可以在结构体里定义函数。

但是C++不建议使用struct关键字来定义类，而是使用class关键字。

```cpp
class 类名{···};
```

> 类和对象的三大特点：封装，继承，多态
>
> 类中依旧存在内存对齐，当类中没有成员变量只有成员函数时，其大小为1字节。这一个字节不存储有效数据，只用来表示对象被实例化。

你可以在类外定义指定类的成员函数。

```cpp
class 类名{···};
type 类名::成员函数名(){}
```

> 虽然是在类外定义的成员函数，但是其作用域和生命周期并没有改变，依旧相当于在类的内部进行了定义。

## 成员函数和成员

在类中定义的函数称作类**成员函数**，变量称作**成员变量**。

成员变量在对象中，成员函数不在对象中。

因为每个对象的成员变量是不同的，但是同一个类的不同对象调用的是一样的函数。所以每个对象调用成员函数是一样的，放到一个公共区域（代码段）。

> 因为成员函数不在对象中，而是在代码段中。所以如果成员函数中没有使用类成员变量，那么即使是通过空指针调用成员函数，也能正常执行程序。因为你实际上没有访问空指针。而如果成员函数中使用了成员变量，那么你就需要访问对象的地址，此时发生了空指针的解引用，报错。
>
> C++11支持给成员变量给缺省值

### 访问类成员和成员函数

使用 `.`来访问类的成员和成员函数

```cpp
类名.成员函数名(实参表);
类名.成员名
```

> 只有在类外访问其公共的成员和成员函数时才需要这样写，私有成员和成员函数只有在类的内部才能访问，也不需要 `.`操作符，直接使用成员或成员函数名访问即可

### this指针

this指针指代对象自己，通过哪个对象访问的类，this就指向那个对象。当同一个类有不同对象时，this用来区分每个对象,确认是哪个对象调用了类成员函数，或是确认应当使用哪个对象的成员。this在类创建时被编译器定义，不需要手动定义。

this存在于栈中，是每个类成员函数隐含的参数，只能在成员函数中使用。（VS中是通过ecx寄存器）

this是const的，不能被修改。

> 事实上，如果在成员函数中使用成员变量，都隐含了this，因为每个对象的成员变量的值是不同的。但是一般不需要显式指明。
>
> ```cpp
> this->成员变量 = 值;
> 成员变量 = 值;
> ```
>
> 上面两种语法作用相同

### static
#### static成员变量
static成员属于整个类，而非单独属于某个对象。

普通的成员变量，在每个对象中的值互不影响，但是static成员变量是 此类的所有对象共有的，在某个对象中修改了static成员的值，其他对象中的值也会被修改。

```cpp
class 类名{
	static 变量类型 变量名;
}
```
你可以通过类去访问static成员变量。也可以通过其对象去访问
```cpp
类名::变量名;
对象名.变量名;
对象指针->变量名;
```
> static修饰的成员变量储存在静态区
```cpp
类型 类名::变量名 = 值;
```
> static修饰的成员变量不能给缺省值，只能这样初始化

#### static成员函数
ststic成员函数属于类，而非单独属于整个对象。

static成员函数没有隐含的this指针，所以无法访问普通成员变量。
```cpp
class 类名
	static 类名 成员函数(){
		···
	}
}
```
你可以通过类去访问static成员函数。也可以通过其对象去访问
```cpp
类名::成员函数();
对象名.成员函数();
对象指针->成员函数();
```

## 类对象的实例化

类在定义和声明时并不会开辟空间，只有在实例化相应的类对象时才会开空间。（相当于建立结构体对象时才会开辟结构体空间)

```cpp
类名 对象名;
```
### 匿名对象
匿名对象没有名字，声明周期只在当前行。
```cpp
类名();
```
有时候不想创建对象但想要一次性的调用类成员函数，便可以使用匿名对象
```cpp
//打印成员函数返回值
cout << 类名().成员函数() <<endl;
//返回一个类对象的函数
类名 函数(){
	return 类名();
}
```

## 访问限定

我们可以限定变量和成员函数的权限

- public公有
- private私有
- protected保护

公有变量和成员函数可以在类外访问，私有和保护的变量和成员函数只能在类中访问.

> class定义的类的成员函数默认为private，struct定义的类的成员函数默认为public（为了和C兼容）
>
> 但是我们依旧建议写明其权限，即使和默认的权限一样
>
> 访问限定符只在编译中有用，映射到内存后并无区别

```cpp
class类名{
private:
	私有变量和成员函数
public:
	公有变量和成员函数
}
```

### 封装

封装就是隐藏对象的属性和实现细节，只通过接口来调用它。而不追究其内部实现。

C++控制数据和成员函数的访问方式，可以在类外访问的为公有，不可以的为私有。

使这得数据和成员函数的访问更安全，更不容易出错。

## 运算符重载

部分运算符是不支持作用于自定义类型的，如日期之间就不能使用 `<` ,`>`等操作符

为了让自定义类型的对象可以使用运算符，出现了运算符重载的概念。

运算符重载让我们可以自定义运算符的作用。

```cpp
返回值类型 operator运算符(参数表){
	···
}
```

> - 实际上这是一个函数，在使用运算符时，如果发现运算符被重载了，就会使用被重载的运算符，此时相当于调用了这个函数。
> - 运算符重载必须至少有一个自定义类型参数
> - 不能重载内置类型的运算符，如内置的整形 `+`(除此之外 `.*`，`::`，`sizeof`，`?:`，`.`也不能重载)
> - 作为类成员函数时，其形参比操作数少1，因为有一个隐含的this指针。
> - 运算符重载对内置类型没有影响

### 运算符重载的例子

下面两段代码重载了==运算符，用来比较日期是否相等

在类外重载

```cpp
 //定义日期类
class Date{
	int _year;
	int _month;
	int _day;
}
//重载==运算符
bool operator==(const Date& d1, const Date& d1){
	//当年月日都相等时返回true，否则为false
	return d1._year == d2._year
	&& d1._month == d2._month
	&& d1._day == d2._day;
}
//下面两行作用相同，都是比较两个自定义的日期类型是否相等
d1 == d2;
operator==(d1,d2);
```
在类中重载
```cpp
//定义日期类
class Date{
public:
	//重载==运算符
	bool operator==(const Date& d1, const Date& d1){
		//当年月日都相等时返回true，否则为false
		return d1._year == d2._year
		&& d1._month == d2._month
		&& d1._day == d2._day;
	}
private:
	int _year;
	int _month;
	int _day;
}

//下面两行作用相同，都是比较两个自定义的日期类型是否相等
d1 == d2;
d1.operator==(d2);
```

### 前置++和后置++重载

前置++和后置++运算符重载在函数名上是一模一样的，为了避免混淆，前置++是无参的，后置++是有一个int型的参数的。这个参数只是为了占位，用来使编译器检测到后置++时使用后置++的重载而不是错误的使用了前置++的重载

```cpp
class Date{
	Date& operator++(){
		_day += 1;
		return *this
	}
	Date operator++(int){
		Date tmp(*this);
		_day += 1;
		return tmp;
	}
}
```

### 流插入和流提取重载

```cpp
istream& operator>>(istream& in,类名 对象名){
	cin >> 提取到的成员变量;
	return istream;
}
ostream& operator<<(ostream& out,类名 对象名){
	cout << 输出的成员变量;
	return ostream;
}
```

## const成员函数

当const修饰成员函数时，其实是修饰隐含的this指针，作用是使得在成员函数中不能修改所有的成员变量。

```cpp
class 类名{
	成员函数() cosnt{
		···
	}
}
```

> 如果我们在实例化对象时使用const修饰对象，这时候对象时不能修改的，但是this指针默认是可以修改的，此时调用类中的成员函数，会出现权限放大而报错。此时休要修饰this指针为const，但是this是被编译器隐式声明的参数，所以我们只能通过给成员函数加const间接给this加const。

## 默认成员函数

大部分的类，在创建对象时都应该初始化，删除对象时要释放资源。手动的进行这些步骤十分容易出错，而且程序员本身可能根本忘了这些行为。这时候C++提供了类的默认函数来自动的进行这些常用行为。

每个类都有默认函数，如果我们没有手动实现某个默认函数，将由编译器自动实现。

> C++11可以给成员变量给初始值，相当于给构造函数不能处理内置类型打了补丁

### 构造函数

构造函数名与类名相同，对象实例化时编译器自动调用对应的构造函数，用来初始化对象。

构造函数没有返回值，可以重载。

```cpp
class 类名{
	构造函数名(参数表){

	}
}
```

> 编译器自动生成的，无参的，全缺省的构造函数都叫做默认构造函数

构造函数无参和有参时实例化对象的语法不同

```cpp
类名 对象名; //创建对象并调用默认构造函数
类名 对象名(参数表);	//创建对象并调用有参构造函数
```

> 调用默认构造函数时不能使用 `类名 对象名()`的方式调用无参构造函数，因为这种写法容易混淆，编译器不知道你是要声明函数还是实例化对象

如果构造函数只有一个参数，则支持：
```cpp
类名 对象名 = 参数;
```
> 这实际上发生了隐式类型转换，把参数转换为自定义类型，然后调用拷贝构造函数。

> 在C++11后，多参数构造函数的对象也支持使用=实例化
> ```cpp
> 类名 对象名 = {参数1, 参数2, ···};
> ```

编译器自动实现的构造函数有时候不能令人满意：

1. 不会处理内置类型的成员变量，只会处理自定义类型（调用自定义类型的构造函数）
2. 构造函数初始化的值是随机的
3. 不会调用基类的构造函数

只有在不在意这些的时候编译器自动实现的构造函数才是有用的。

#### explicit关键字

ecplicit关键字可以强制让构造函数在被赋值时无法被类型转换，也就是说，ecplicit关键字修饰的构造函数，无法使用`类名 对象名 = 参数`的形式赋值；
```cpp
class 类名{
	explicit 构造函数(){
		···
	}
}
```
#### 初始化列表
初始化列表：以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个"成员变量"后面跟一个放在括号中的初始值或表达式。

作用是将类的每个成员变量初始化为其后面的括号内的值。
```cpp
class Date{
public:
	Date(int year.int month, int day)
		:_year(year)
		,_month(month)
		,_day(day)
	{
		···
	}
private:
	int _year;
	int _month;
	int _day;
}
```
1. 每个成员变量在初始化列表中只能出现一次(初始化只能初始化一次)
2. 类中包含以下成员，必须放在初始化列表位置进行初始化：
	1. 引用成员变量
	2. const成员变量
	3. 自定义类型成员(且该类没有默认构造函数时）
3. 尽量使用初始化列表初始化，因为不管你是否手动显式的使用初始化列表，对于自定义类型成员变量，编译器会自动隐式的使用初始化列表初始化。
4. 初始化列表中的初始化顺序是成员变量的声明顺序，而非其在初始化列表中的先后次序无关
### 析构函数

析构函数名为类名前加 `~`，在对象销毁时自动调用，完成对象中的资源清理（对象本身的销毁由编译器完成，析构函数只清理对象中的资源）。

析构函数没有参数和返回值，一个类只能由一个析构函数。

```cpp
class 类名{
	~析构函数名(){

	}
}
```

> 编译器自定义的析构函数有与构造函数相同的特点
>
> * 不会处理内置类型的成员变量，只会处理自定义类型（调用自定义类型的构造函数）
> * 不会调用基类的析构函数

### 拷贝构造

拷贝构造函数是构造函数的一种，只是规定了其参数必须是一个对象的引用，且作用是拷贝依旧旧的同类对象。

> 我们也可以通过指针传参来实现拷贝构造的功能，但依旧不叫做拷贝构造函数，只是普通的构造函数。

```cpp
class 类名{
	拷贝构造函数名(const 类名& 对象名){
		实现拷贝;
	}
}
```

当你实例化一个新的对象，这个对象是一个旧对象的拷贝时，就需要用到拷贝构造函数。

```cpp
类名 新对象(被拷贝的旧对象);
类名 新对象 = 被拷贝的旧对象;
```

> **为什么需要拷贝构造函数？**
>
> 拷贝时，内置类型可以直接按字节拷贝。但是自定义类型进行按字节的浅拷贝可能会导致两个对象的成员变量指向同一片空间，此时对这个空间的操作就变得极为危险，两个对象的成员操作同一片空间，比如a调用了析构函数释放了这片空间，然后b销毁时，也会调用析构函数，此时这片空间依旧被释放，程序会直接崩溃。所必须使用拷贝构造函数进行深拷贝。

拷贝构造函数是构造函数的重载，拷贝构造函数只有一个参数，是新对象要拷贝的旧对象的引用。

> **为什么是引用？**
>
> 假设拷贝构造函数的参数是传值传参。当发生拷贝时，需要调用拷贝构造函数，但是拷贝构造函数的参数是传值传参，又需要拷贝，需要调用拷贝构造函数。但是拷贝构造函数的参数是传值传参 ，·······。程序陷入了死循环，无限的递归下去。所以拷贝构造函数的第一个参数必须是引用传参，不能发生拷贝。

> 因为只是做了拷贝，没有修改旧对象的值。所以参数最好使用const。

> 默认拷贝构造函数与构造函数不同，基本类型和自定义类型都会被拷贝构造函数处理，但都是基本的浅拷贝，在部分情况下我们需要自定义拷贝构造函数来进行深拷贝才行。

### 赋值运算符重载

我们常常重载=运算符来实现对象的拷贝

```cpp
类名& operator=(const 类名& 对象名){
	if(*this != &对象){
		实现拷贝
	}
	return *this;
}
```

> 一般返回一个对象自身的引用来实现连续赋值
>
> **赋值运算符只能重载成类的成员函数不能重载成全局函数**；原因：赋值运算符如果不显式实现，编译器会生成一个默认的。此时用户再在类外自己实现一个全局的赋值运算符重载，就和编译器在类中生成的默认赋值运算符重载冲突了，故赋值运算符重载只能是类的成员函数。
>
> 用户没有显式实现时，编译器会生成一个默认赋值运算符重载，以值的方式逐字节拷贝。注意：内置类型成员变量是直接赋值的，而自定义类型成员变量需要调用对应类的赋值运算符重载完成赋值。
>
> 如果类中未涉及到资源管理，赋值运算符是否手动实现都可以；一旦涉及到资源管理则必须要手动实现。

> `类名 对象1 = 对象2` 此时是拷贝构造，不是赋值重载。赋值重载是将一个已存在的对象拷贝给另一个已经存在的对象。拷贝构造是使用旧对象实例化新对象，新对象是旧对象的拷贝。
>
### 取地址重载

取地址重载有两种，取地址重载和const取地址重载；编译器都会默认会生成。

```cpp
class Date{ 
public :  
	Date* operator&() {
		return this ;
    	}  
	const Date* operator&() const{
		return this ;  
}
private :   
	int _year ; // 年  
	int _month ; // 月  
	int _day ; // 日
};
```
> 这两个运算符一般不需要重载，使用编译器生成的默认取地址的重载即可，只有特殊
