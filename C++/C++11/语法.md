## {}初始化

C++98就已经支持部分对象使用{}初始化

```C++
int array[] = {1, 2, 3};
Date obj = {2012, 9, 9};
```

但在C++，这种支持更加广泛,一切对象均可以使用{}初始化，且可以省略赋值符号
```C++
int array[]{1,2,3};
Date obj{2012, 9, 9};
```
>实际上是隐式调用构造函数

可以指定对象不能被{}初始化
```C++
explicit class 类名
{}
```

### 通过任意个数的值构造对象(C++11)

arrary，list，vector,map等都容器都支持传入任意个数的值
```C++
int arrray[]{1,2,3,4};
vector<int> v{1,2,3,4};
list<int> l{1,2,3,4};
```

这是通过initializer_list实现的，如果传入的数据不能调用其他的构造函数，那么会将所有数据存入initializer_list中，然后通过initializer_list去构造对象

```C++
class list{
	list(const std::initializer_list<int>& data){} 
}
```

有一种写法来调用多参对象

```C++
vector<map> vm = {{key1,value1}, {key2,value2}};
```

## 构造类型相同的变量

可以使用decltype作为变量类型，来构造与某个变量（常量）类型相同的新变量

```C++
int x;
decltype(x) y;// y的类型与x相同
```

## 右值引用

右值：一般出现在赋值符号右边。字面量，运算表达式，临时变量（函数的非引用返回值）。



右值引用可以对右值取别名
```C++
type&& 名称=右值；
```

 右值引用可以引用move后的左值
```C++
type&& 名称 = move(左值); 
```

### 移动构造
右值引用的作用在于减少构造的代价
```C++
string s1 = "123";
string s2 = s1 +"456";
```
我们分析s2的构造过程，编译器先构造了一个临时变量来进行s1+"123"的运算，然后将临时变量赋值给s2，然后将临时变量销毁。

我们可以将临时变量称作将亡值，其在运算结束后销毁，

但是s2的值与将亡值完全相同，那么为什么要将其赋值给s2后销毁呢？不如直接将临时变量的资源分配给s2即可。省去了一次拷贝和销毁

```C++
string s1 = "123";
string&& s2 = s1 +"456";
```
> 实际上，编译器会自动优化，当面对临时对象时自动进行右值引用，调用移动构造，不需要手动声明。

这种称作移动构造，需要类中实现相应的移动构造接口。如：

```C++
class string{
	string(string&& tmp_str){
		swap(tmp_str);
	}
}
```
> C++11后，STL的所有容器都增加了右值引用版本

### 引用折叠(万能引用)

引用和模板结合可以进行万能引用。使得d其既可以引用左值，也可以引用右值。
```C++
class<typename T>
void fun(T&& data){};
```


### 完美转发

当右值被引用后，其属性成为了左值。此时如果使用这个值，将会被当成左值处理。
```C++
void fun1(type&& data){
	fun2(data);//data此时被当成左值传入fun2
}
```
我们可以使用完美转发来保持其右值属性

```C++
void fun1(type&& data){
	fun2(forward<type>(data));//data此时被当成左值传入fun2
}
```

