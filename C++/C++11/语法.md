## {}初始化

C++98就已经支持部分对象使用{}初始化

```C++
int array[] = {1, 2, 3};
Date obj = {2012, 9, 9};
```

但在C++，这种支持更加广泛,一切对象均可以使用{}初始化，且可以省略赋值符号
```C++
int array[]{1,2,3};
Date obj{2012, 9, 9};
```
>实际上是隐式调用构造函数

可以指定对象不能被{}初始化
```C++
explicit class 类名
{}
```

### 通过任意个数的值构造对象(C++11)

arrary，list，vector,map等都容器都支持传入任意个数的值
```C++
int arrray[]{1,2,3,4};
vector<int> v{1,2,3,4};
list<int> l{1,2,3,4};
```

这是通过initializer_list实现的，如果传入的数据不能调用其他的构造函数，那么会将所有数据存入initializer_list中，然后通过initializer_list去构造对象

```C++
class list{
	list(const std::initializer_list<int>& data){} 
}
```

有一种写法来调用多参对象

```C++
vector<map> vm = {{key1,value1}, {key2,value2}};
```

## 构造类型相同的变量

可以使用decltype作为变量类型，来构造与某个变量（常量）类型相同的新变量

```C++
int x;
decltype(x) y;// y的类型与x相同
```

## 右值引用

右值：一般出现在赋值符号右边。字面量，运算表达式，临时变量（函数的非引用返回值）。



右值引用可以对右值取别名
```C++
type&& 名称=右值；
```

 右值引用可以引用move后的左值
```C++
type&& 名称 = move(左值); 
```

### 移动构造和移动赋值
右值引用的作用在于减少构造的代价
```C++
string s1 = "123";
string s2 = s1 +"456";
```
我们分析s2的构造过程，编译器先构造了一个临时变量来进行s1+"123"的运算，然后将临时变量赋值给s2，然后将临时变量销毁。

我们可以将临时变量称作将亡值，其在运算结束后销毁，

但是s2的值与将亡值完全相同，那么为什么要将其赋值给s2后销毁呢？不如直接将临时变量的资源分配给s2即可。省去了一次拷贝和销毁

```C++
string s1 = "123";
string&& s2 = s1 +"456";
```
> 实际上，编译器会自动优化，当面对临时对象时自动进行右值引用，调用移动构造，不需要手动声明。

这种称作移动构造，需要类中实现相应的移动构造接口。如：

```C++
class string{
//移动构造
	string(string&& tmp_str){
		swap(tmp_str);
	}
	//移动赋值
	operator=(string&& tmp_str){
		swap(tmp_str);
	}
}
```
> C++11后，STL的所有容器都增加了右值引用版本

### 引用折叠(万能引用)

引用和模板结合可以进行万能引用。使得d其既可以引用左值，也可以引用右值。
```C++
class<typename T>
void fun(T&& data){};
```


### 完美转发

当右值被引用后，其属性成为了左值。此时如果使用这个值，将会被当成左值处理。
```C++
void fun1(type&& data){
	fun2(data);//data此时被当成左值传入fun2
}
```
我们可以使用完美转发来保持其右值属性

```C++
void fun1(type&& data){
	fun2(forward<type>(data));//data此时被当成左值传入fun2
}
```

## emplace成员函数系列

STL中每个容器基本都有emplace系列的函数来进行插入，其与push系列的语法相同，其在大部分情况下效率相同。

但在涉及构造时，会有差别，push系列会先构造匿名对象，然后去移动构造，emplace系列会直接构造对象。

在深拷贝时，效率差别反而不大。在涉及浅拷贝时，反而会有较大的性能差距。 

## lambda表达式

lambda表达式创建了一个仿函数对象，通过UUID保证对象名不会重复。所以其不支持互相赋值，因为每个lanbda对象都是不同的仿函数对象。

```lambda
[捕获列表](参数列表)mutable->返回值类型{函数体}
```

- 捕获列表：可以捕获外部变量至函数体，捕获列表可省略，\[\]不可省略。
	- 捕获的对象默认是const的
	- 捕捉和参数一样，有传值和引用两种
- 参数列表可以连同()一起省略，表示无参
- mutable可以修改捕获的变量的const性，可省略
- 返回值可省略，表示返回空或者返回类型明确。
- 函数体内可以正常写代码

### 捕获列表

捕获时可以传值捕获和引用捕获两种
```C++
[&a, b]->{};//a是传值捕捉，b是引用捕捉
```

可以指定捕捉全部变量
```C++
[&]->{};//引用捕捉全部变量
[=]->{};//传值捕捉全部变量
```

可以指定特例
```C++
[&,a]->{};//a是传值捕捉，其他全是引用捕捉
[=,b]->{};//b是引用捕捉，其他全为传值捕捉
```

## 线程库

Linux支持的线程库和Win下的线程库不一样，C语言的线程库只能支持Linux编程。

C++封装了thread库，他支持多个平台的线程库。


### this_thread

this_thread是std的一个子命名空间，封装了线程相关

get_id()获取线程id
sleep_for()休眠一段时间
sleep_util()休眠至某个时间

原子操作：当线程要修改数据时。先检查数据，当数据已经被其他线程被修改时，不进行操作，未被修改时，才进行修改。

这样可以实现无锁时的线程安全。