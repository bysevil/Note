## {}初始化

C++98就已经支持部分对象使用{}初始化

```C++
int array[] = {1, 2, 3};
Date obj = {2012, 9, 9};
```

但在C++，这种支持更加广泛,一切对象均可以使用{}初始化，且可以省略赋值符号
```C++
int array[]{1,2,3};
Date obj{2012, 9, 9};
```
>实际上是隐式调用构造函数

可以指定对象不能被{}初始化
```C++
explicit class 类名
{}
```

### 通过任意个数的值构造对象(C++11)

arrary，list，vector,map等都容器都支持传入任意个数的值
```C++
int arrray[]{1,2,3,4};
vector<int> v{1,2,3,4};
list<int> l{1,2,3,4};
```

这是通过initializer_list实现的，如果传入的数据不能调用其他的构造函数，那么会将所有数据存入initializer_list中，然后通过initializer_list去构造对象

```C++
class list{
	list(const std::initializer_list<int>& data){} 
}
```

有一种写法来调用多参对象

```C++
vector<map> vm = {{key1,value1}, {key2,value2}};
```

## 构造类型相同的变量

可以使用decltype作为变量类型，来构造与某个变量（常量）类型相同的新变量

```C++
int x;
decltype(x) y;// y的类型与x相同
```

## 右值引用

右值：一般出现在赋值符号右边。字面量，运算表达式，临时变量（函数的非引用返回值）。



右值引用可以对右值取别名
```C++
type&& 名称=右值；
```

 右值引用可以引用move后的左值
```C++
type&& 名称 = move(左值); 
```

### 移动构造和移动赋值
右值引用的作用在于减少构造的代价
```C++
string s1 = "123";
string s2 = s1 +"456";
```
我们分析s2的构造过程，编译器先构造了一个临时变量来进行s1+"123"的运算，然后将临时变量赋值给s2，然后将临时变量销毁。

我们可以将临时变量称作将亡值，其在运算结束后销毁，

但是s2的值与将亡值完全相同，那么为什么要将其赋值给s2后销毁呢？不如直接将临时变量的资源分配给s2即可。省去了一次拷贝和销毁

```C++
string s1 = "123";
string&& s2 = s1 +"456";
```
> 实际上，编译器会自动优化，当面对临时对象时自动进行右值引用，调用移动构造，不需要手动声明。

这种称作移动构造，需要类中实现相应的移动构造接口。如：

```C++
class string{
//移动构造
	string(string&& tmp_str){
		swap(tmp_str);
	}
	//移动赋值
	operator=(string&& tmp_str){
		swap(tmp_str);
	}
}
```
> C++11后，STL的所有容器都增加了右值引用版本

### 引用折叠(万能引用)

引用和模板结合可以进行万能引用。使得其既可以引用左值，也可以引用右值。
```C++
class<typename T>
void fun(T&& data){};
```


### 完美转发

当右值被引用后，其属性成为了左值。此时如果使用这个值，将会被当成左值处理。
```C++
void fun1(type&& data){
	fun2(data);//data此时被当成左值传入fun2
}
```
我们可以使用完美转发来保持其右值属性

```C++
void fun1(type&& data){
	fun2(forward<type>(data));//data此时被当成左值传入fun2
}
```

## emplace成员函数系列

STL中每个容器基本都有emplace系列的函数来进行插入，其与push系列的语法相同，其在大部分情况下效率相同。

但在涉及构造时，会有差别，push系列会先构造匿名对象，然后去移动构造，emplace系列会直接构造对象。

在深拷贝时，效率差别反而不大。在涉及浅拷贝时，反而会有较大的性能差距。 

## lambda表达式

lambda表达式创建了一个仿函数对象，通过UUID保证对象名不会重复。所以其不支持互相赋值，因为每个lanbda对象都是不同的仿函数对象。

```lambda
[捕获列表](参数列表)mutable->返回值类型{函数体}
```

- 捕获列表：可以捕获外部变量至函数体，捕获列表可省略，\[\]不可省略。
	- 捕获的对象默认是const的
	- 捕捉和参数一样，有传值和引用两种
- 参数列表可以连同()一起省略，表示无参
- mutable可以修改捕获的变量的const性，可省略
- 返回值可省略，表示返回空或者返回类型明确。
- 函数体内可以正常写代码

### 捕获列表

捕获时可以传值捕获和引用捕获两种
```C++
[&a, b]->{};//a是传值捕捉，b是引用捕捉
```

可以指定捕捉全部变量
```C++
[&]->{};//引用捕捉全部变量
[=]->{};//传值捕捉全部变量
```

可以指定特例
```C++
[&,a]->{};//a是传值捕捉，其他全是引用捕捉
[=,b]->{};//b是引用捕捉，其他全为传值捕捉
```

## 线程库

Linux支持的线程库和Win下的线程库不一样，C语言的线程库只能支持Linux编程。

C++封装了thread库，他支持多个平台的线程库。

线程对象创建时，如果调用的函数使用引用方式接收参数，不能直接传参数,需要使用ref()
```C++
thread obj(fun,one,two,mtx);//报错
thread obj(fun,ref(one),ref(two),ref(mtx));
```


### this_thread

this_thread是std的一个子命名空间，封装了线程相关

get_id()获取线程id
sleep_for()休眠一段时间，如休眠10秒
sleep_util()休眠至某个时间，如休眠至 2024年5月1日
yield()当前线程停止运行状态，去运行队列尾排队，其他线程开始运行。

> thread类的get_id()在

原子操作：当线程要修改数据时。先检查数据，当数据已经被其他线程被修改时，不进行操作，未被修改时，才进行修改。

这样可以实现无锁时的线程安全。

### 互斥锁 mutex

#### 递归锁 recursive_mutex

和普通锁方法相同，但是避免了递归调用时，在自己持有锁的情况下再次加锁导致的死锁问题。

#### 时间锁 time_mutex

多了两个接口

try_lock_until() 加锁到指定时间点时强制线程释放锁
try_lock_for() 线程持有锁一段时间后强制释放锁

### 条件变量

## 原子操作库
原子操作库保护了数据操作的原子性。不会因为执行流被CPU切走而出现数据不一致问题。一般用来就行无锁编程（CAS）;
## 包装器


包装器可以将函数，仿函数，成员函数，lambda表达式封装为模板类。

```C++
function<返回值(形参表)> 对象名= 函数名，仿函数或lambda表达式;
```
如：
```C++
function<int(int,int)> f1= fun;//函数指针
function<int(int,int)> f2= fun();//仿函数
function<int(int,int)> f3= [](int,int)->{};//lambda表达式
```

此时这三者被封装为同一类型，可以使用同一种方法来调用;

### 包装成员函数

包装静态成员函数时没有什么区别

```C++
function<返回值(形参表)> 对象名= 类名::成员函数名;
```

但是包装非静态成员时需要注意，其函数的第一个参数为隐含的this指针，所以第一个形参是一个类，使用时也需要传对象。

包装示例：
```C++
function<Date(Date,int,int)> f = &Date::func;
```
使用示例：
```C++
f(Date(),10,10);
```

### 绑定
利用绑定改变包装后的参数顺序
```C++
function<> 对象 = bind(可包装对象,placeholders::_2,placeholders::_1)
```
> 第1个参数将会变成第2个参数，第2个参数将会编程第1个参数

利用绑定改变参数个数
```C++
function<> 对象 = bind(&Date::func,Date(),placeholders::_1,placeholders::_2);
```

给予某个参数一个固定值，且使这个参数不能被传入。
## 异常

正常来说遇到异常时，程序会报错退出。我们可以手动抛出一个异常。

### 抛出异常
```C++
throw(异常对象);//异常对象可以时内置类型(int,char)，也可以是自定义类型；
```

在对异常捕获后，程序在try内发生异常，将会跳转到catch语句对异常进行处理。并将异常作为对象发生给catch。

### 捕获异常
```C++
try{
	//正常代码;
}catch(异常对象){
	//处理异常的代码;
}
```

可以使用多个catch，异常抛出后匹配最近的同类型catch。
```C++
try{
	//正常代码;
}catch(const char* e)){
	//处理抛出char*类型异常的代码
}catch(cost string e){
	//处理抛出string类型异常的代码
}
```

一般来说，会专门定义一个类作为异常抛出和捕获的类型

```C++
class Exception{
private:
	int _errid; //错误码
	string _errmsg; //错误描述
};
```

捕获任意类型的异常
```C++
try{

}catch(...){
	cout << "未知异常" << endl;
}
```

> 子类异常可以被父类捕获
> 异常捕获可以嵌套多层，可以在捕获异常后，处理特化部分后再抛给最外层处理通用部分。

### 异常声明

C++98要求在函数声明时，声明会抛出什么类型的异常
```C++
void fun() throw(异常1，异常2);
```
> 如果throw内为空，则表明函数不抛异常

C++98的方案要求开发者明确能不能抛异常和能抛出什么异常，但是实际开发中，开发者不一定能给出准确的能抛出哪些异常

在C++11中，只要求开发者标识哪些函数不会抛异常

```C++
void fun() noexcept;
```


## 智能指针

智能指针将指针封装成类，通过其构造和析构实现了安全的资源申请和释放，避免了资源泄漏。

```C++
template<class T>
class SmartPtr(){
	T* _data;
	SmartPtr(T* data)
	:_data(data)
	{}
	~SmartPte(){
		delete _data;
	}
}
```

### 拷贝问题

指针指针将指针封装成了类，这样的话，如果对这个类进行拷贝，会导致多个指针指向同一片资源且多次释放的问题

C++98为了解决这个问题，使用了auto_ptr。其思路是，所有权转移，当新的智能指针是旧指针的拷贝，则让旧指针悬空，新指针指向资源。

> auto_ptr在c++17被舍弃

### unque_ptr
在C++11，引用了新的智能指针来代替auto_ptr。

分别为unque_ptr,shared_ptr,weak_ptr;

unque直接禁用了拷贝，让智能指针始终只有一个，避免了资源多次释放。

但是有时候我们确实有两个指针指向同一片空间的场景

### shared_ptr
shared_ptr是允许被拷贝的智能指针，他通过引用计数的方式来判断是否进行资源释放，如果计数不为0，则不会释放资源，只会释放智能指针；

>但是引入引用计数后，为了让多个shared_ptr看到计数，其需要被开辟在堆上，那么对于引用计数的操作不是线程安全的，

shared_ptr通过加锁方式开实现了自身的线程安全，但是shared_ptr管理的对象依旧不是线程安全的。

### weak_ptr
循环引用会使得shared_ptr无法正常释放
```C++
n1->next = n2;
n2->prev = n1;
```
因为n1的next指向n2，n2的prev指向n1，导致两个人的引用计数都不能变为0。

为了解决这个问题，引出了weak_ptr,weak_ptr指向资源，但不影响引用计数。

> 为了使得waek_ptr正常工作，shared_ptr也做出了改变。在引用计数变为0时，也不释放资源，只是标记资源不可用。等待所有weak_ptr也退出时，才释放资源。这是为了让weak_ptr能确定资源是否可用，如果直接释放，使用weak_ptr时，无法保证资源是可用的。

### 定制删除器

智能智能一般只能管理new出来的单个对象，无法管理malloc出的对象，或是new的连续空间。因为他们无法被正常释放。

这时候出现了定制删除器，其为当作智能指针创建时的第二个参数。

定制删除器应该是一个函数对象，实现正确的删除智能指针管理的空间。

## 特殊类设计

### 对象只能创建在堆上（只能被new出来）

思路1：私有化析构函数，通过destory接口释放自己

```C++
template<class T>
Class HeapOnly{
	void Destory(){
		delete this;
	}
private:
	~HeapOnly(){};
	T _data;
};
```

思路2：私有化构造函数，提供静态成员函数创建对象
```C++
template<class T>
Class HeapOnly{
	static HeapOnly* CreateObj(int data){
		HeapOnly* p = new HeapOnly();
		return p;
	}
private:
	HeapOnly(){};
	HeapOnly(const HeapOnly& x) = delete;
	HeapOnly(HeapOnly&& x) = delete;
	T _data;
};
```

### 对象只能创建在栈上

思路：私有化构造函数，提供静态成员函数创建对象

```C++
template<class T>
Class StackOnly{
	static StackOnly CreateObj(int data){
		StackOnly s(data);
		return s;
	}
private:
	HeapOnly(int date)
	:_date(date)
	{};
	T _data;
};
```

缺点：无法管理静态对象

### 单例模式
一个对象在程序内只能有一个,其他同类对象只是这个唯一对象的引用。

#### 饿汉模式

在程序启动时创建这个唯一对象

缺点：
1. 单例对象很大时，main之前就要申请，但暂时不需要使用，却占用资源
2. 无法控制多个单例对象的初始化顺序
```C++
class Singletion(){
public:
	static Singletion* CreateInstance(){
		return _ins;
	}
private:
	Singlention(){};
	vetcor<T> _data;
	Singletion* _ins;
};

Singletion* Singletion::_ins = new Singletion;
```

#### 懒汉模式
在第一次使用时创建唯一对象

相对来说懒汉几乎没有缺点，应用更加广泛。

```C++
class Singletion(){
public:
	static Singletion* CreateInstance(){
		if(_ins == nullptr){
			_mtx.lock();
			if(_ins == nullptr){
				_ins = new Singletion;
			}
			_mtx.unlock();
		}
		return _ins;
	}
private:
	mutex _mtx;
	Singlention(){};
	vetcor<T> _data;
	Singlention* _ins;
};
Singletion* Singletion::_ins = nullptr;
mutex Singletion::mtx;
```

#### 回收单例对象
创建全局内部类对象，当对象销毁时，调用单例对象的销毁。
```C++
class Singletion(){
public:
	static Singletion* CreateInstance(){
		if(_ins == nullptr){
			_mtx.lock();
			if(_ins == nullptr){
				_ins = new Singletion;
			}
			_mtx.unlock();
		}
		return _ins;
	}

	static void DelInstance(){
		_mtx.lock();
		if(_ins){
			delete _ins;
			_ins = nullptr;
		}
		_mtx.unlock();
	}

	class GC(){
	public:
		~GC(){
			DelInstance();
		}
	}
	static GC _gc;
private:
	mutex _mtx;
	Singlention(){};
	vetcor<T> _data;
	Singlention* _ins;
};

Singletion* Singletion::_ins = nullptr;
mutex Singletion::mtx;
Singletion::GC Singletion::_gc;
```