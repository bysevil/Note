Linux支持的线程库和Win下的线程库不一样，C语言的线程库只能支持Linux编程。

C++封装了thread库，他支持多个平台的线程库。

线程对象创建时，如果调用的函数使用引用方式接收参数，不能直接传参数,需要使用ref()
```C++
thread obj(fun,one,two,mtx);//报错
thread obj(fun,ref(one),ref(two),ref(mtx));
```


## this_thread

this_thread是std的一个子命名空间，封装了线程相关

get_id()获取线程id
sleep_for()休眠一段时间，如休眠10秒
sleep_util()休眠至某个时间，如休眠至 2024年5月1日
yield()当前线程停止运行状态，去运行队列尾排队，其他线程开始运行。

> thread类的get_id()在

原子操作：当线程要修改数据时。先检查数据，当数据已经被其他线程被修改时，不进行操作，未被修改时，才进行修改。

这样可以实现无锁时的线程安全。

## 互斥锁 mutex

### 递归锁 recursive_mutex

和普通锁方法相同，但是避免了递归调用时，在自己持有锁的情况下再次加锁导致的死锁问题。

### 时间锁 time_mutex

多了两个接口

try_lock_until() 加锁到指定时间点时强制线程释放锁
try_lock_for() 线程持有锁一段时间后强制释放锁

## 条件变量

## 原子操作库
原子操作库保护了数据操作的原子性。不会因为执行流被CPU切走而出现数据不一致问题。一般用来就行无锁编程（CAS）;