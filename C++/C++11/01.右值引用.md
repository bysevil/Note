
右值：一般出现在赋值符号右边。字面量，运算表达式，临时变量（函数的非引用返回值）。


右值引用可以对右值取别名
```C++
type&& 名称=右值；
```

 右值引用可以引用move后的左值
```C++
type&& 名称 = move(左值); 
```

## 移动构造和移动赋值
右值引用的作用在于减少构造的代价
```C++
string s1 = "123";
string s2 = s1 +"456";
```
我们分析s2的构造过程，编译器先构造了一个临时变量来进行s1+"123"的运算，然后将临时变量赋值给s2，然后将临时变量销毁。

我们可以将临时变量称作将亡值，其在运算结束后销毁，

但是s2的值与将亡值完全相同，那么为什么要将其赋值给s2后销毁呢？不如直接将临时变量的资源分配给s2即可。省去了一次拷贝和销毁

```C++
string s1 = "123";
string&& s2 = s1 +"456";
```
> 实际上，编译器会自动优化，当面对临时对象时自动进行右值引用，调用移动构造，不需要手动声明。

这种称作移动构造，需要类中实现相应的移动构造接口。如：

```C++
class string{
//移动构造
	string(string&& tmp_str){
		swap(tmp_str);
	}
	//移动赋值
	operator=(string&& tmp_str){
		swap(tmp_str);
	}
}
```
> C++11后，STL的所有容器都增加了右值引用版本

## 引用折叠(万能引用)

引用和模板结合可以进行万能引用。使得其既可以引用左值，也可以引用右值。
```C++
class<typename T>
void fun(T&& data){};
```


## 完美转发

当右值被引用后，其属性成为了左值。此时如果使用这个值，将会被当成左值处理。
```C++
void fun1(type&& data){
	fun2(data);//data此时被当成左值传入fun2
}
```
我们可以使用完美转发来保持其右值属性

```C++
void fun1(type&& data){
	fun2(forward<type>(data));//data此时被当成右值传入fun2
}
```


