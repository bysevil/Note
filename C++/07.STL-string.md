## 查看字符串大小
查看字符串所占的字符数
```cpp
str.size();
```
查看字符串所占的空间
```cpp
str.capacity();
```
## 查找，取出字符
使用`find`返回指定内容的下标
```cpp
//查找h在字符串首次出现的下标
str.find('h');
//查找h在字符串5个字符之后首次出现的下标
str.find('h',5);
```
使用`[ ]`取出指定下标字符的引用
```cpp
str[num];
```
使用`at()`取出指定下标的引用
```cpp
str.at(num);
```
> 使用at时出错抛异常，使用`[ ]`出错直接断言出错。

## 改变字符(串)
使用`+`连接两个字符串，支持连续连接。
```cpp
string str = "Hello" + ' ' + "World";
```
追加字符(串)有许多方式，但是建议使用`+=`运算符
```cpp
//追加字符
str.push_back('s');
//追加字符串
str.append("str");
//追加字符或字符串
str += "str";
```
指定位置插入字符(串)
```cpp
//头插字符串“hello”
str.insert(0,"hello");
//头插5个字符'x'
str.insert(0,5,'x');
```
删除字符
```cpp
//删除字符串5个字符后的所有内容
str.erase(5);
//删除字符串5个字符后3个字符的内容
str.erase(5,3)
```
替换字符
```cpp
//修改字符串5个字符后1个字符的内容为“hello”
str.replace(5,1,"hello");
```
## 改变字符串占用空间

扩容支持原地扩容，在空间足够时可以原地扩容。

缩容不支持原地缩容，必须开辟一片新空间并复制。所以尽量不要进行缩容。
### 自动扩容机制
string相比于char\[ \]的一个优势在于，他会自动扩容。而非需要手动扩容。
> 不同编译器和环境下实现并不相同
>- VS下每次扩容1.5倍
>- G++下每次扩容2倍
### 扩容
reserve和resize用来改变字符串所占空间
```cpp
str.reserve(100);
str.resize(100);
```
>扩容字符串可使用的空间为100字节

reserve只改变所占空间大小和复制原有数据，resize则对未使用的空间进行初始化
```cpp
str.resize(10,'x');
```
> 对之前未使用的空间按字节初始化为x，使用过的空间进行复制。
### 缩容（删除字符串内容）
所占空间支持向小改变
```cpp
str.reserve(1);
str.resize(1);
```
> 同时对多余的字符进行删除，相当于只保留了前1个字节的内容

## 迭代器
迭代器就是取出一个整体中的其中一个元素，可以按元素来遍历整体。

对于字符串来说，就是取出其中一个字符。然后可以按字符遍历字符串。

创建string类的迭代器对象：
```cpp
//正向迭代器
string::iterator it;
//反向迭代器
string::reverse_iterator rit;
//const正向迭代器
string::const_iterator it;
//const逆向迭代器
string::const_reverse_iterator it;
```
> const对象只能用const迭代器接收
> 
> 可以使用auto简化语法，自动判断用什么迭代器接收

返回一个迭代器：
```cpp
//返回指向正向的首部的迭代器
str.begin();
//返回指向正向的尾部的迭代器
str.end();

//返回指向逆向的首部的迭代器
str.rbegin();
//返回指向逆向的尾部的迭代器
str.rend();
```
> 返回const迭代器
> ```cpp
>//返回指向正向的首部的const迭代器
>str.cbegin();
>//返回指向正向的尾部的const迭代器
>str.cend();
>
>//返回指向逆向的首部的const迭代器
>str.crbegin();
>//返回指向逆向的尾部的const迭代器
>str.crend();
>```
>事实上，返回const迭代器只是为了结构工整，使用普通的成员函数也可以，不需要指定返回const迭代器

### 使用迭代器遍历字符串

正向：
```cpp
//创建string类型的迭代器，指向字符串str的首部
string::iterator it = s1.begin();

//当迭代器未迭代到尾部的时候，继续循环
while(it != s1.end()){
	cout << *it << endl;//打印字符
	++it;//迭代至下一个字符
}
```
逆向：
```cpp
//创建string类型的迭代器，指向字符串str的首部
string::reverse_iterator rit = s1.rbegin();

//当迭代器未迭代到尾部的时候，继续循环
while(it != s1.rend()){
	cout << *rit << endl;//打印字符
	++rit;//迭代至下一个字符
}
```

> 事实上，因为字符串支持迭代器，所以可以使用范围for