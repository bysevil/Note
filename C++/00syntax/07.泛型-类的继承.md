继承是一种类层次的代码复用。如果多个类有共同的特征，可以将这些共同特征提取出来，放在另一个类中。这个类称为父类或基类，其他具有共同特征的类可以通过继承这个类来获得这些共同特征。

```c++
class 父类 
{···};

class 子类名 : 继承方式 父类名 
{···};
```

继承并不是在子类中生成父类的所有成员变量和成员函数，而是在子类中包含了父类的所有成员。子类可以直接使用父类的非私有成员变量和函数。
## 继承方式

> 继承方式可以省略，子类为class默认私有继承，为struct时默认公有继承。但一般建议写明

继承有3种：
- public：保持成员的访问权限
- protected：将继承的成员变为保护成员
- private：将继承的成员变为私有成员

不同的继承方式会改变父类中保护和公有成员被继承后的权限。但是私有成员无法被子类访问，所以不会改变权限。友元关系也不会被继承。

>实际一般使用公有继承
>
>静态成员变量也会被继承，因为静态成员变量属于整个类，这个类包括子类和父类，所以子类使用的也是父类的静态成员变量，不会像普通继承那样，在子类中隐式生成父类的成员。

## 隐藏/重定义

如果子类和父类中有同名成员（函数和变量），子类会屏蔽对父类成员的直接访问，这叫做隐藏或重定义。

> 此时父类的成员依旧存在，只不过被隐藏了
>
>也就是说，在子类中访问这个同名成员时，只会访问子类的成员。只有加上访问限定符，才会访问父类的成员。
>
>在父类和子类中，只需要函数名相同就可以构成隐藏，不需要参数不同。
>
>一般不要进行重定义

## 派生类的默认成员函数

派生类在不显式定义默认成员函数时，会自动调用父类的默认构造函数来初始化自己。

如果显式定义了默认构造函数，需要在其中调用父类的默认构造函数来处理继承的成员变量，然后处理自己独有的成员变量。
> 在子类的默认成员函数中无法直接操作继承自父类的成员变量

如果没有在自己默认成员函数中显示调用父类的默认成员函数，编译器会自动隐式的调用父类的默认成员函数。构造时先调用父类的构造，在调用自己的。析构时先调用自己的，在调用父类的。

>析构函数不允许显式调用父类的
>
> 直接调用父类析构函数会报错，因为析构函数会被编译器自动重命名为 destructor，父类和子类都被重命名为同一个函数名，构成了重定义。所以C++编译器会自动调用父类的析构函数，此时加访问限定符可以访问父类的析构函数，但是会调用两次父类的析构函数，因为已经被隐式自动调用了一次。

## 赋值兼容

可以将子类对象直接赋值给父类，指向子类对象的指针也可以赋值给指向父类对象的指针。这会发生切片。
```c++
父类对象 = 子类对象;
父类指针 = 子类指针;
```

> 切片不会发生隐式类型转换，是直接切割。将子类地址空间中父类的部分直接切割出来赋值给父类（指针）
> 
>父类对象无法赋值给子类，指向父类对象的指针也无法赋值给子类指针
## 多继承

一个父类可以有多个子类，一个子类也可以有多个父类
```c++
class 子类 : 继承方式 父类1, 继承方式 父类2
{}
```

这种灵活性导致了菱形继承的出现，也就是一个父类，其有两个子类，这两个子类，又有一个共同的子类。

这就导致了共同子类继承了其两个父类的成员变量，二两个父类又是同时继承自其共同父类的，这就导致了：
1. 冗余性：同时继承了两个同名变量，而且这两个同名变量可能具有相同数据。
2. 二义性：使用变量时不明确使用的是哪个父类继承来的变量，必须添加访问限定符。
### 虚继承

虚继承解决了多继承的数据冗余和二义性问题

```c++
class 子类 ： virtual 继承方式 父类
{}
```
> 虚继承在菱形继承中，只需要给有共同父类的两个子类使用

在菱形继承中，共同子类会有两份共同父类的成员变量的值，分别存储在其继承的两个父类中，为了避免这种情况，虚继承会让共同子类中只有一份成员变量的值，存储在子类空间的最后，而在其本来该在的位置中存储一个指针（虚基表指针），这个指针指向的数据为空，其下一个位置存储父类成员变量相对于虚继承生成的一份成员变量的偏移量。

> 也就是说，虚继承只多了两个指针的空间，用来指向存储偏移量的数据位置的指针，而使得两份数据只需要存储一份，然后通过偏移量寻找就行。

为什么存储偏移量：因为赋值兼容，存储绝对地址，当子类对象以赋值兼容的形式给父类时，如果访问绝对位置，访问的还是子类对象的值，而存储偏移量，在赋值兼容后，指向的就是父类对象的值了。

## 组合

组合和继承都是内部类的复用方式

```C++
class A
{}

class B
{
private:
	A _objA;
}
```
这种称作B组合A

> 这种的优点在于耦合度低，A中发生了修改很难影响到B。在为继承关系时，A任何修改都容易对B造成改变。

## 继承禁止(C++11)
final关键字的作用是让类无法被继承

```c++
class 类名 final {}
```

