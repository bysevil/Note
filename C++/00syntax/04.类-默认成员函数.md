## 默认成员函数

大部分的类，在创建对象时都应该初始化，删除对象时要释放资源。手动的进行这些步骤十分容易出错，而且程序员本身可能根本忘了这些行为。这时候C++提供了类的默认函数来自动的进行这些常用行为。

每个类都有默认函数，如果我们没有手动实现某个默认函数，将由编译器自动实现。

> C++11可以给成员变量给初始值，相当于给构造函数不能处理内置类型打了补丁

### 构造函数

构造函数名与类名相同，对象实例化时编译器自动调用对应的构造函数，用来初始化对象。

构造函数没有返回值，可以重载。

```cpp
class 类名{
	构造函数名(参数表){
		···
	}
}
```

> 编译器自动生成的，无参的，全缺省的构造函数都叫做默认构造函数

构造函数无参和有参时实例化对象的语法不同

```cpp
类名 对象名; //创建对象并调用默认构造函数
类名 对象名(初始化列表); //创建对象并调用有参构造函数
```

> 调用默认构造函数时不能使用 `类名 对象名()`的方式调用无参构造函数，因为这种写法容易混淆，编译器不知道你是要声明函数还是实例化对象

如果构造函数只有一个参数，则支持：

```cpp
类名 对象名 = 参数;
```

> 这实际上发生了隐式类型转换，把参数转换为自定义类型，然后调用拷贝构造函数。

> 在C++11后，多参数构造函数的对象也支持使用=实例化
>
> ```cpp
> 类名 对象名 = {参数1, 参数2, ···};
> ```

编译器自动实现的构造函数有时候不能令人满意：

1. 不会处理内置类型的成员变量，只会处理自定义类型（调用自定义类型的构造函数）
2. 构造函数初始化的值是随机的
3. 不会调用基类的构造函数

只有在不在意这些的时候编译器自动实现的构造函数才是有用的。

#### explicit关键字

ecplicit关键字可以强制让构造函数在被赋值时无法被类型转换，也就是说，ecplicit关键字修饰的构造函数，无法使用`类名 对象名 = 参数`的形式赋值；

```cpp
class 类名{
	explicit 构造函数(){
		···
	}
}
```

#### 初始化列表

初始化列表：以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个"成员变量"后面跟一个放在括号中的初始值或表达式。

作用是将类的每个成员变量初始化为其后面的括号内的值。

```cpp
class Date{
public:
 Date(int year.int month, int day)
  :_year(year)
  ,_month(month)
  ,_day(day)
 {
  ···
 }
private:
 int _year;
 int _month;
 int _day;
}
```

1. 每个成员变量在初始化列表中只能出现一次(初始化只能初始化一次)
2. 类中包含以下成员，必须放在初始化列表位置进行初始化：
	 1. 引用成员变量
	 2. const成员变量
	 3. 无默认构造函数的自定义类型成员
3. 尽量使用初始化列表初始化，因为不管你是否手动显式的使用初始化列表，对于自定义类型成员变量，编译器会自动隐式的使用初始化列表初始化。
4. 初始化列表中的初始化顺序是成员变量的声明顺序，而非其在初始化列表中的先后次序无关

### 析构函数

析构函数名为类名前加 `~`，在对象销毁时自动调用，完成对象中的资源清理（对象本身的销毁由编译器完成，析构函数只清理对象中的资源）。

析构函数没有参数和返回值，一个类只能由一个析构函数。

```cpp
class 类名{
 ~析构函数名(){

 }
}
```

> 编译器自定义的析构函数有与构造函数相同的特点
>
> - 不会处理内置类型的成员变量，只会处理自定义类型（调用自定义类型的构造函数）
> - 不会调用基类的析构函数

### 拷贝构造

拷贝构造函数是构造函数的一种，只是规定了其参数必须是一个对象的引用，且作用是拷贝依旧旧的同类对象。

> 我们也可以通过指针传参来实现拷贝构造的功能，但依旧不叫做拷贝构造函数，只是普通的构造函数。

```cpp
class 类名{
 拷贝构造函数名(const 类名& 对象名){
  实现拷贝;
 }
}
```

当你实例化一个新的对象，这个对象是一个旧对象的拷贝时，就需要用到拷贝构造函数。

```cpp
类名 新对象(被拷贝的旧对象);
类名 新对象 = 被拷贝的旧对象;
```

> **为什么需要拷贝构造函数？**
>
> 拷贝时，内置类型可以直接按字节拷贝。但是自定义类型进行按字节的浅拷贝可能会导致两个对象的成员变量指向同一片空间，此时对这个空间的操作就变得极为危险，两个对象的成员操作同一片空间，比如a调用了析构函数释放了这片空间，然后b销毁时，也会调用析构函数，此时这片空间依旧被释放，程序会直接崩溃。所必须使用拷贝构造函数进行深拷贝。

拷贝构造函数是构造函数的重载，拷贝构造函数只有一个参数，是新对象要拷贝的旧对象的引用。

> **为什么是引用？**
>
> 假设拷贝构造函数的参数是传值传参。当发生拷贝时，需要调用拷贝构造函数，但是拷贝构造函数的参数是传值传参，又需要拷贝，需要调用拷贝构造函数。但是拷贝构造函数的参数是传值传参 ，·······。程序陷入了死循环，无限的递归下去。所以拷贝构造函数的第一个参数必须是引用传参，不能发生拷贝。

> 因为只是做了拷贝，没有修改旧对象的值。所以参数最好使用const。

> 默认拷贝构造函数与构造函数不同，基本类型和自定义类型都会被拷贝构造函数处理，但都是基本的浅拷贝，在部分情况下我们需要自定义拷贝构造函数来进行深拷贝才行。

### 赋值运算符重载

我们常常重载=运算符来实现对象的拷贝

```cpp
类名& operator=(const 类名& 对象名){
	if(*this != &对象){
		实现拷贝
	}
	return *this;
}
```

> 一般返回一个对象自身的引用来实现连续赋值
>
> **赋值运算符只能重载成类的成员函数不能重载成全局函数**；原因：赋值运算符如果不显式实现，编译器会生成一个默认的。此时用户再在类外自己实现一个全局的赋值运算符重载，就和编译器在类中生成的默认赋值运算符重载冲突了，故赋值运算符重载只能是类的成员函数。
>
> 用户没有显式实现时，编译器会生成一个默认赋值运算符重载，以值的方式逐字节拷贝。注意：内置类型成员变量是直接赋值的，而自定义类型成员变量需要调用对应类的赋值运算符重载完成赋值。
>
> 如果类中未涉及到资源管理，赋值运算符是否手动实现都可以；一旦涉及到资源管理则必须要手动实现。

> `类名 对象1 = 对象2` 此时是拷贝构造，不是赋值重载。赋值重载是将一个已存在的对象拷贝给另一个已经存在的对象。拷贝构造是使用旧对象实例化新对象，新对象是旧对象的拷贝。
>
### 取地址重载

取地址重载有两种，取地址重载和const取地址重载；编译器都会默认生成。

```cpp
class Date{ 
public :  
	Date* operator&() {
		return this ;
    }  
	const Date* operator&() const{
		return this ;  
	}
private :   
	int _year ; // 年  
	int _month ; // 月  
	int _day ; // 日
};
```

> 这两个运算符一般不需要重载，使用编译器生成的默认取地址的重载即可，只有特殊

### 移动构造和移动赋值(C++11)
编译器会决定是否实现默认的移动构造（赋值）
1. 没有显式实现移动构造（赋值）
2. 没有显式实现析构，拷贝构造，拷贝赋值
> 也就是说当类不需要深拷贝时系统会生成默认的移动构造（赋值）

我们可以强制生成
```C++
class Date{
private:
	Date(Date&& tmp_date) = default;
	operator=(Date&& tmp_date) = default;
};
```

也可以禁止生成
```C++
class Date{
private:
	Date(Date&& tmp_date) = delete;
	operator=(Date&& tmp_date) = delete;
};
```