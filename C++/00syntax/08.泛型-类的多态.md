同一个行为，在遇到不同对象时返回不同的结果。

1. 子类重写父类的虚函数
2. 使用父类的指针或者引用去调用

满足多态时，虽然使用的是父类的指针，但进行的是相应的子类的虚函数。

不满足多态时，看指针的类型，调用其函数。
## 虚函数

```c++
virtual 返回值 函数名(参数列表){}
```

> 虚函数和虚继承没有关系

>友元函数不在类中，不能设置为虚函数
>静态成员函数没有this指针，无法通过this找虚表，不能设置为虚函数。
>析构函数建议实现为虚函数，来正确的释放对象
### 覆盖/重写

重写是在子类中重写父类的虚函数

1. 参数表相同
2. 返回值相同
3. 函数名相同 
```c++
class A{
public:
	virtual void fun();
}

class B{
	void fun();
}
```
> 重写时，子类的成员函数可以不是虚函数

> 重写只重写了函数的实现，不会重写函数的声明，也就是形如
> ```c++
>class A{
>public:
>	vertual void fun(int val =0);
>}
>class B{
>	vertual void fun(int val = 1);
>}
> ```
> 也就是在多态调用B的fun时，其val默认值是0。只有在直接调用B的fun时，val默认值才是1
#### 标识省略

在子类中重写父类的虚函数时不加虚函数标识。

```c++
class A{
public:
	virtual void fun();
}

class B{
public:
	void fun();
}
```
> 注意，此时子类也是虚函数，只不过标识被省略了。
#### 协变

协变指的是在重写的时候，返回值可以不同。

但这种不同是有限制的，返回值虽然不同，但父类虚函数的返回值和子类虚函数的返回值必须是具有父子关系的类的引用或者指针。
```C++
class A{
public:
	vertual A* fun();
}

class B{
public:
	vertual B* fun();
}
```
> 此时子函数的虚函数标识也可以省略

#### 重写检查与禁止(C++11)

override关键字的作用是检查虚函数是否被重写，如果没有被重写，则报错
```c++
virtual void fun() override {}
```

final关键字的作用是让虚函数无法被重写

```c++
virtual void fun() final {}
```

### 纯虚函数

纯虚函数是只有声明没有实现的虚函数。

```C++
virtual void fun() = 0;
```

纯虚函数没办法被使用，只有重写后才能使用

> 纯虚函数可以有函数体，但是意义不大
#### 抽象类/接口类

类中只有纯虚函数的类叫做抽象类，抽象类无法实例化出对象。

### 虚函数表

在有虚函数对象被实例化时，会生成一个指针，在vs下，这个指针叫做`_vfptr`，指向的是一个函数指针数组，这个数组里面存的是当前类中所有虚函数的地址。

> 一般来说虚函数指针数组的最后一个存储的是nullptr

在调用虚函数时，会根据这个虚函数表来调用相应的虚函数。因为子类指针在赋值兼容成父类指针时，虚函数表还是子类的虚函数表，所以实现了多态调用。

> 所以必须是引用或者指针才能触发多态，因为子类对象赋值兼容为父类时，虚表是父类的虚表

虚表指针存储在对象的前面，在调用构造函数的时候初始化，被隐含在初始化列表中。（所以构造函数不能是虚函数）

虚表被存储在常量区中。