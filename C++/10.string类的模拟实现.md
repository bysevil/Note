## 成员变量
表示当前字符串空间容量
```cpp
size_t _capacity = 0;
```
表示当前字符串使用了多少容量
```cpp
size_t _size = 0;
```
表示C风格字符串
```cpp
char* _str = nullptr;
```
## 默认成员函数实现
### 默认构造
```cpp
string(const char* str = "") {
	int len = strlen(str) + 1;
	reserve(len);
	memcpy(_str, str, len);
	_size = len - 1;
}
```
1. 默认开1字节的空间，起码存放一个\\0
2. _capacity在扩容时会赋值，不需要再赋值
3. memcpy默认拷贝一个\\0，保证不是空串
### 拷贝构造
```cpp
string(const string& s) {
	*this = s;
}
```
1. 直接调用赋值重载
### 赋值重载
```cpp
string& operator=(const string& s) {
	if (this != &s) {
		reserve(s._capacity);
		_size = s._size;
		memcpy(_str, s._str, _size + 1);
	}
	return *this;
}
```
1. 先判断，防止自己赋值给自己
2. 返回自身的引用来实现连续赋值
3.reserve始终不会发生缩容，所以不要担心缩容问题，放心调用拷贝构造
### 析构
```cpp
~string() {
	delete[] _str;
	_str = nullptr;
	_size = _capacity = 0;
}
```
1. 不需要考虑对象为空串，因为最少也存放了一个\\0
## 查看属性
### 查看size
```cpp
size_t bysevil::string::size() const {
	return _size;
}
```
### 查看capacity
```cpp
size_t bysevil::string::capacity() const {
	return _capacity;
}
```
### 返回C风格字符串
```cpp
const char* bysevil::string::c_str() const {
	return _str;
}
```
## 改变容量
### 扩容
```cpp
void reserve(size_t n) {
	if (n > _capacity) {
		char* tmp = new char[n];
		assert(tmp != nullptr);
		if (_size != 0) {
			memcpy(tmp, _str, _size + 1);
			delete[] _str;
		}
		_str = tmp;
		_capacity = n;
	}
}
```
1. 只有在新容量大的时候扩容，不缩容
2. 只有当原来不是空串的时候拷贝内容，否则只扩空间