## 命名空间

在C语言中，同一作用域中不能定义同名变量。

但是涉及全局变量和函数时，你无法保证多个文件的全局变量和函数名字都不相同。特别是在多人协作时，这个问题尤为明显。

此时，C++使用了命名空间来解决这个问题，不同命名空间的变量和函数可以重名；

命名空间只影响查找规则，使用变量时，默认会去局部找，然后去找全局，除非指定，否则不会去找命名空间的内容。但是命名空间不影响生命周期，只影响使用。

> - C++标准库中的内容都在命名空间 `std`中

### 定义命名空间

```C++
namespace 空间名{
	···
}
```

> 多个文件定义同一命名空间，会被认为是同一个命名空间而被合并。
>
> 命名空间可以嵌套

### 访问命名空间

#### 域访问限定符 `::`

使用指定命名空间的内容

```C++
空间名::内容名
```

> - 当空间名为空时，表示全局域
>
> ```C++
> ::变量名
> ```
>
> - 访问嵌套空间需要多个域访问限定符

#### 全局展开

如果你的代码不涉及命名冲突，这时候你访问命名空间中的变量和函数等每次都需要使用域访问限定符，十分繁琐。

这时候你可以指定命名空间全局展开，此时你访问这个空间内的内容就不需要域访问限定符了。

```c++
using namespace 空间名;
```

> 改变了查找规则，先在局部，然后全局，然后找展开的命名空间。而非全局找不到就认为内容未定义。
> 一般情况下，不建议全局展开

#### 部分展开

全局展开及其容易导致名称冲突，但是我们又不想每次使用时使用域访问限定符。此时可以部分展开。

部分展开只展开指定内容，使用部分展开的内容时不需要域访问限定符。

```c++
using 空间名::内容名
```

## 输入和输出

### 输出

C++一般使用流插入操作符，将输出插入到标准输出流的方式进行输出

```C++
cout << "hello world";
```

流插入操作符支持连续插入

```C++
cout << "hello" << "world";
```

插入句尾回车

```C++
cout << "hello world" << endl;
```

### 输入

使用流提取操作符从标准输入流获取输入

```C++
cin >> val1 >> val2;
```

> 这种方式会自动获取输入的类型;

## 缺省参数（默认参数）

我们给函数传参的时候，需要一一对应。

我们可以给参数一个默认值，在没有传递参数的时候，使用这个默认值。

```c++
type fun(type val){
    ···
}
type fun(type val = 值);
```

> 如果所有参数都是缺省参数，则称作全缺省
>
> 缺省参数不能声明和定义同时给，一般建议声明时给。除非不需要额外声明。

### 半缺省

部分参数缺省，部分不缺省称为半缺省

半缺省时，缺省参数必需从右往左连续缺省

```c++
//正确
void fun(int a,int b = 0,int c = 0);

//错误
void fun(int a = 0,int b);
```

## 函数重载

如果在同一作用域有两个同名函数，但是参数表不同。则称为函数重载。

```c++
int add(int,int);
double add(double,double);
```

> 函数重载时返回值可以不同，但是只有返回值不同不能构成重载

> 重载主要看的是形参的类型和类型的顺序
>
> ```c++
> int add(int a,int b);
> int add(int b,int a);
> ```
>
> 不算是函数重载

### 函数重载的原理

函数重载本质上时因为编译器对函数名进行了修饰，所以在编译器看来是不同名的函数

在VS下，

```C++
int add(int,int);
double add(double,double);
int funtion(int);
```

会被修饰为

```C++
_Z3addii;
_Z3adddd;
_Z7funtioni;
```

即 `_Z` + `函数名长度` + `形参表每个参数类型的首字母`;

> 每个编译器的修饰方式不同

## 引用

引用可以理解为给已经存在的变量取一个别名，两个变量名使用同一片内存空间，不会开辟新空间。

改变其中一个的值另一个的值也会改变，因为两个变量名实际上使用的是同一个内存空间；

```C++
变量类型& 引用名 = 变量名; 
```

> - 引用必须在定义时指明其引用的主体（必须初始化），且不能再引用别的主体。
> - 引用必须和变量是一个类型
> - 一块空间可以有多个别名
> - 对别名也可以取别名
> - 引用从汇编上看是用指针实现的

### 引用传参

引用传参的作用是：形参是实参的别名而非拷贝，所以改变形参值也会改变实参值;

```C++
int add(int& a,int& b){
    ···
}
```

### 引用返回

正常的函数返回值，实际上时创建了一个临时变量，然后将返回值拷贝到临时变量，然后销毁函数栈帧，将临时变量返回，然后销毁临时变量。

但是如果这个返回值不会随着函数栈帧的销毁而销毁（比如说它是一个静态变量，或是malloc动态开辟的），此时创建临时变量并拷贝就有点多次一举，我们可以使用引用返回，这时候就返回返回值的引用。这将不会发生拷贝，更加高效。

```C++
int& fun(){
	stactic ret = 1;
	return ret;
}
```

而且引用返回的对象既可以作为右值，也可以作为左值被修改。

```cpp
int& fun(){
}

int main(){
	fun() = 10;
}
```

### 引用的权限

指针和引用在赋值或者初始化时，权限可以缩小，但不能放大。

权限缩小:

```cpp
int a = 0;
const int& b = a;
```

权限放大（报错）:

```cpp
const int a = 0;
int& b = a;
```

值得注意的是，所有临时变量都具有const性

```cpp
int a = 0;
const double& b = a;
```

> 因为a是int，b是double，所以a会发生隐式类型转换，这会生成一个double型的临时变量，然后赋值给b，所以b必须为const的

```cpp
int fun() {}
const int& b = fun();
```

> 因为函数返回值不是引用类型，所以会创建临时变量。所以b必须为const

## 内联函数

C++不建议使用宏。建议使用const和enum代替宏常量，使用inline去代替宏函数

内联函数虽然是函数，但是不会建立新的栈帧，也不会进入符号表。他会在调用处展开，同时又不像宏一样只是简单的替换。使得其具有宏的优点的同时又不具有宏的缺点。

```cpp
inline type funtion(){};
```

但是多次使用inline函数编译出的程序的体积会较大。(只是程序本身的体积会较大)

> inline对于编译器而言只是一个建议，所以不同编译器对于inline的实现并不相同。
>
> 而且有的编译器实际上会忽略inline，内联函数被认为是普通函数。
>
> 一般来说，内联用于优化规模较小，流程直接，频繁调用的函数。
>
> 很多编译器不支持内联递归函数。
>
> 事实上，如果函数体积较大，展开是不合理的。
>
> 内联不建议声明和定义分离，头文件中不可以包含内联函数。你可以在不同文件中定义名称相同实现不同的内联函数。

## 自动类型

C++可以不显式的声明类型，而使用关键字 `auto`去定义，这时候编译器会自动根据其初始化的值推断其类型

```shell
auto 变量名 = 值;
```

我们也可以查看变量的具体类型

```shell
typeid(变量名).name()
```

> auto不能在一行声明不同类型的变量
>
> auto不能做形参
>
> auto不能声明数组

## 范围for（C++11）

范围for指的是，给定一个范围，在一个范围内遍历。

```shell
for (类型 变量名 : 范围){}
```

> 这个范围可以给数组，或者字符串等迭代器对象。他会自动的遍历字符串或者数组。并且每次循环将遍历到的值赋值给变量。
>
> 一般来说，类型使用auto关键字

遍历时是将遍历到的值赋值给临时的变量，改变这个变量不会改变原数组的值。但是我们可以使用引用；

```cpp
for(type& val:array){}
```

注意，指针不允许这样去用。而数组作为参数时，传的是指针，此时不能使用范围for。

## C++中的空指针

C++中使用nullptr指空指针。这是因为NULL在C++中指代空指针会出现一些问题。

NULL是一个宏，在C++中被定义为0。

比如有一个重载函数，一个函数的参数是指针，一个函数的参数是整型。我们传入NULL，此时会被认为是整型的0，而非空指针。
