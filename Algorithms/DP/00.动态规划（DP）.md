
动态规划的核心思想是将问题拆解成重复子问题。从重复子问题来逐步推出问题答案。

经典的问题是斐波那契数列。如果我们要求第n个数。我们可以先求第一个数，然后推出第二个数。然后通过第2个数推出第三个数。。。直到推出第三个数。

## DP问题的求解思路（斐波那契数列）
1. 状态表示

一般定义一个DP表，表示一个状态，逐步填写这个DP表来获得答案。

如在斐波那契数列中，我们可以定义一个数组dp\[n\]，其中，dp\[i\]代表第i个斐波那契数。dp\[n\]即为问题的答案。

2. 状态转移方程

我们需要一个公式来逐步的填写dp表(由前一个状态推出下一个状态），

如在斐波那契数列中，其递推公式为
dp\[i\] = dp\[i-1\] + dp\[i-2\];

3. 初始化（处理边界问题）

一般定义dp表为数组，则需要防止数组越界问题。

如在斐波那契数列中，如果i等于1，则递推时，i-2为-1，数组越界。我们可以通过先手动填写dp\[1\]和dp\[2\] 然后从dp\[3\]开始再利用dp公式填表即可。

而且，因为dp\[n\]才是答案，则定义数组时，需要至少需要定义为dp\[n+1\]大小才行。

4. 填表顺序

因为dp表是由一个小问题的答案推出另一个小问题的答案，然后推出问题答案。则如果我们需要推出某个问题的答案时，则需要其前置问题的答案已经被推出才行。

在斐波那契数列中，如果我们要得知dp\[i\]则需要dp\[i-1\]和dp\[i-2\]都已经被推出。所以我们需要从dp\[1\]开始填表，然后才是dp\[2\]，然后dp\[3\]。。。直到dp\[n\];

5. 返回值

我们需要确定dp表的哪个位置才是问题的答案

如在斐波那契问题中，dp\[n\]才是问题的答案。
```C++
class Solution {
public:
    int tribonacci(int n) {
	    if(n <= 2) return 1;
	    int dp[n] = { 0 };
	    dp[1] = 1;
	    dp[2] = 1;
	    for(int i = 3; i <= n; i++){
		    dp[i] = dp[i-1] + dp[i-2];
	    }
        
        return dp[n];
    }
};
```
## 滚动数组优化空间

在斐波那契数列中，我们确定了第i个数是多少时，此时往下推i+1时，我们只用到了 i+1 ，i，i-1三个数。在推i+2时，只需要得知 i+2 , i +1, i即可。

所以，我们大可不必定义一个数组来存储每个数，再推到第i个数时，我们只需要得知其前两个数即可。我们可以只定义三个数，滚动的向下推，直到推到第n个数。

```C++
class Solution {
public:
    int tribonacci(int n) {
	    //处理边界问题
	    if(n <= 2) return 1;
	    //a代表i-1（之前推出的数）,b代表i（已经推出的数）,c代表i+1（要推的数）
        int a = 1, b = 1;
        for(int i = 3; i <= n; i++){
	        int c = a + b;
	        a = b
		    b = c;
        }
        
        return b;
    }
};
```