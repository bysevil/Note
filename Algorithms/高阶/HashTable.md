哈希表（也称散列表），其将key与其存储位置建立关联关系，用来达到快速查找。

我们可以直接映射，如直接将key当作数组下标，来将value映射到数组里。但这样的方法在key过大或者过于分散时并不好用。

## 间接映射
 除留余数法：数据分散时使用，以将key转换为int型，除一个余数后存入（一般用哈希表的大小取余）
 
 有些可能不能直接转换，如字符串，和某些自定义对象。 为了泛型，可以提供模板函数，用来让用户自己提供映射规则。

在映射字符串时，我们发现"abcd","dcba","aadd"等数直接转换成int型的结果相同，为此，我们需要提供另一套映射规则：
```C++
size_t ret= 0;
for(auto e: str){
	ret = 31*ret + e;
	//这个数可以是31，13131等
}
```
> STL里已经对string型进行了特化，所以无需自己提供
 
间接映射可以能导致不同的key映射到同一个位置，导致冲突，为了解决这种冲突，我们可以使用开放地址法，或是拉链法。
### 开放地址法

- 线性探测：
	- 冲突时依次找向下个位置找，找到有效位置
- 二次探测：
	- 冲突时再次哈希一次，多次哈希直到找到有效位置

在数据大量冲突时，操作的代价就会变大，为了解决这种情况，我们引入负载因子

$负载因子 = \frac{有效数据个数}{哈希表容量}$

负载因子越大，引发冲突的可能性就越高，就需要扩容。一般来说，我们需要负载因子不大于0.7~0.8，具体值可自行定夺。

### 拉链法
冲突时将数据以链式结构后缀在相应位置，这样避免了冲突

但有一种极限情况，即负载因子只有0.1或更小，但某一个位置后缀了许多数据（极难发生）

为了避免这种情况，可以在每次插入后查看最长链的长度，如果过长，则将链表转化为红黑树来后缀在相应位置。

## 扩容

在扩容后，所有映射关系都需要改变。需要开辟新空间，所有数据重新映射。然后释放就空间。

>有一种说法是使用素数大小的空间效率更高，在SGI实现中，提供了一个素数表来作为容量基准，扩容时在素数表中找下一个素数。


