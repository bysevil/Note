哈希表（也称散列表），其将key与其存储位置建立关联关系，用来达到快速查找。

我们可以直接映射，如直接将key当作数组下标，来将value映射到数组里。但这样的方法在key过大或者过于分散时并不好用。

## 间接映射
 除留余数法：数据分散时使用，以将key转换为int型，除一个余数后存入（一般用哈希表的大小取余）
 
 有些可能不能直接转换，如字符串，和某些自定义对象。 为了泛型，可以提供模板函数，用来让用户自己提供映射规则。

在映射字符串时，我们发现"abcd","dcba","aadd"等数直接转换成int型的结果相同，为此，我们需要提供另一套映射规则：
```C++
size_t ret= 0;
for(auto e: str){
	ret = 31*ret + e;
	//这个数可以是31，13131等
}
```
> STL里已经对string型进行了特化，所以无需自己提供
 
间接映射可以能导致不同的key映射到同一个位置，导致冲突，为了解决这种冲突，我们可以使用开放地址法，或是拉链法。
### 开放地址法

- 线性探测：
	- 冲突时依次找向下个位置找，找到有效位置
- 二次探测：
	- 冲突时再次哈希一次，多次哈希直到找到有效位置

在数据大量冲突时，操作的代价就会变大，为了解决这种情况，我们引入负载因子

$负载因子 = \frac{有效数据个数}{哈希表容量}$

负载因子越大，引发冲突的可能性就越高，就需要扩容。一般来说，我们需要负载因子不大于0.7~0.8，具体值可自行定夺。

### 拉链法/哈希桶
冲突时将数据以链式结构后缀在相应位置，这样避免了冲突

但有一种极限情况，即负载因子只有0.1或更小，但某一个位置后缀了许多数据（极难发生）

为了避免这种情况，可以在每次插入后查看最长链的长度，如果过长，则将链表转化为红黑树来后缀在相应位置。

## 扩容

在扩容后，所有映射关系都需要改变。需要开辟新空间，所有数据重新映射。然后释放就空间。

>有一种说法是使用素数大小的空间效率更高，在SGI实现中，提供了一个素数表来作为容量基准，扩容时在素数表中找下一个素数。


## 位图
位图时查找数据是否存在于某个容器中的一种算法。

其将数据映射到某个精确的比特位上，这个位为1，则数据存在.否则数据不存在。

优点：速度快，节省空间。
缺点：只能映射整形

实现时，一般底层使用`vector<char>`来实现，一个char可以代表8个位

### 布隆过滤
为了映射别的类型，我们需要布隆过滤器将其他类型的数据映射成整形。

但这种映射可能存在误判，即两个数据映射到一个位置。为了防止这个问题，我们可以将一个数据映射到多个位置，只有这几个位置都为1，才表明数据确实存在。

>依旧可能出现冲突和误判，但是降低了概率。

布隆过滤的误判只存在于有判无，无肯定不会被判有。所以可以用布隆过滤来确定绝对没有这个值，在需要精确确定有时，可以先用布隆图判断，如果判断有，则在进行精确查找，如果确定没有，直接退出，可以提高程序的效率。

布隆过滤只能插入，不能删除。因为一个数据要映射多个位置，删除后如果删除映射的所有位置，那如果和别的值有重复，那么会导致别的数据查找不准确

## 哈希切分
如果有两份各自包含100亿的quary的文件，此时求这两个文件的交集

进行哈希切分，分割成多个小文件。对每个query，进行哈希，决定进入哪个小文件。此时两个文件切分出的小文件，每个都是一个哈希桶，只有冲突的值才进一个文件。此时只需要每个相同下标的小文件进行比较即可求出交集。