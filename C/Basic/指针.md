# 1.指针是什么

定义：指针是储存内存地址的变量

语法：`type *ptr`

如：
```c
int a = 0;
char b = 'a';

int *ptr_int = &a;//创建了一个int*类型的指针，存放整型变量a的地址
int *ptr_ch = &b;//创建了一个ch*类型的指针，存放整型变量b的地址
```

> 在32位系统中，指针变量恒占4字节，在64位系统中恒占8字节
>
> 这里的`*`只表明这是一个指针变量。而非取值操作符
>
> 指针变量只能存放地址，虽然常数可以被存放，但会被当成地址值读取，这将会形成野指针。
>
> 指针变量可以存放其他变量的地址，但它也拥有自己的地址。

# 2.两个指针相关的运算符

## 2.1 &引用运算符

作用：获取变量的地址

语法：`&VarName`

如：
```c
int a = 0;
int *p = &a;//通过引用运算符获取变量a的指针，赋值给指针变量p；
```

## 2.2 *解引用运算符(间接运算符)。

作用：访问内存地址处储存的值

语法：`*ptr`

如：
```c
 int a = 0;
 int *p = &a;
 printf("%d",*p);//通过解引用来访问指针变量p所储存的地址处的变量的值。
```

# 3.空指针

定义：值为 0 的整型常量表达式，或强制（转换）为`void*`类型的此类表达式，称为空指针常量。

定义：`ptr = 0`	或	`ptr = NULL`

> C标准没有说空指针与指向内存地址0 的指针相同，尽管在实践中可能就是这种情况。解引用空指针是C中的未定义行为，并且允许符合要求的实现假定任何被解除引用的指针不为空。

# 4.错误的指针

**野指针**：访问一个已销毁或者访问受限的内存区域的指针，野指针不能只通过判断是否为NULL来避免

**悬空指针（也称为悬浮，迷途，失控指针）**：指针正常初始化，曾指向一个对象，该对象被销毁了，但是指针未置空（指向NULL）；

**错误指针的产生原因：**

1. 指针定义时未被初始化或未被正确的初始化
2. 指针指向的空间被释放后，指针未置空
3. 指针操作超越变量作用域：不要返回指向栈内存的指针或者引用，因为栈内存在函数结束的时候会被释放。

# 5.将`--`和`++`运算符用于指针

将指针递增或递减时，其包含的地址将增加或减少指向的数据类型的长度，而非直接+1。这样，编译器将确保指针不会指向数据的中间或末尾，而只会指向数据的开头。如果相邻地址的数据类型与所指向的数据类型不同，这将十分麻烦

```c
	int a[] = {1,2,3,4,5};
	int *p = a;//数组名相当于数组首元素地址
	p++;
	printf("%d",*p);//此时输出2;
```

可以看出，p++并没有使得p所在的地址在值上+1.而是加4(一个int型变量的长度)。导致p从指向a\[0]变成了指向a\[1]（数组在内存中连续存储）;

# 6.指针的类型

指针变量的类型并不如其他变量般恒定，如整型变量的类型就是int，字符变量的类型就是char。指针的类型与其指向的空间所存放的值有关，如果指向一个整型，指针的类型就是`int *`，指向字符时，指针的类型就是`char *`。

## 6.1 指向指针的指针（多级指针）

指针可以存放各种变量的地址，包括一个别的指针变量。这称作二级指针。

```c
char str[] = "hello";
char *ptr = &str;
//&为取地址操作符，可以获得变量的地址。
char **ptr2 = &ptr;
//声明并初始化一个二级指针，其中存放指针变量ptr的地址
```

同时，你也可以创建一个三级指针甚至四级指针，不过大部分情况并无必要；

如果要通过二级指针获取str变量的值，需要解引用两次。

```c
 printf("%c",**ptr2);
 //此时打印hello
```

## 6.2 指向函数的指针

指针也可以存放函数地址
```c
void funa(int a,int b){return};
int funb(int a,char b){return};

void(*ptra)(int,int) = funa;
//创建了一个类型为void(*)(int,int)的指针变量，指向函数funa
void(*ptrb)(int,char) = funb;
//创建了一个类型为void(*)(int,cgar)的指针变量，指向函数funb
```

> 函数名等同于函数的地址，如同数组名相当于数组首元素的地址。所以不需要引用操作符&来取地址，当然，你也可以使用`&funa`，但效果相同；

此时函数funa和funb可以通过指针ptra和ptrb以参数的形式传给其他函数并调用:

```c
void func(void(*ptra)(int,int),void(*ptrb)(int,char)){
	int a = 0;
	int b = 1;
	char* str = "hello";
	 
	ptra(a,b);
	//与funa(a,b)等同;
	ptrb(a,str);
	//与fun(a,str)等同;
}

func(ptra,ptrb);
//调用函数func，并将指向函数funa和funb的指针作为参数传入
```

### 6.2.1 回调函数

如果你把函数的指针作为参数传给另一个函数，且在另一个函数中被调用。这个被传入的函数称作回调函数。

在上面的的代码中funa和funb以指针的方式传给func，且在func中被调用，此时funa和funb为回调函数。

回调函数不是被直接调用的，而是被另一方在特定情况下调用，用以对特定的事件进行响应。

回调函数的作用是将代码逻辑分离出来，使得代码更加模块化和可维护。使用回调函数可以避免阻塞程序的运行，提高程序的性能和效率。另外，回调函数还可以实现代码的复用，因为它们可以被多个地方调用。

## 6.3 指向数组的指针

指针可以指向数组，这称作数组指针

```c
int arr[] = {1,2,3,4,5};
int* ptr_int = arr;
//这是我们上面出现过的写法，创建了一个int*类型的指针，指向数组arr的首元素，即arr[0];
int(*ptr_arr)[5] = &arr;
//通过对数组名解引用，我们得到了数组的地址，赋值给类型为int(*)[]的数组指针
```

注意，虽然数组的地址与数组首元素的地址在值上相同，但其表达的含义并不相同：
```c
prt_int++;
printf("%d",*prt_int);//输出2，此时相当于访问arr[1]

pri_arr++;
printf("%d",*prt_int);//输出值未知，数组越界访问
```

在上面代码中，`prt_int++`跳过了一个int大小的数据，也就是从访问arr\[0]变为了arr\[1]，

`prt_arr++`跳过了一个数组大小的数据，也就是一个arr数组（arr数组有5个int型的数据，所以数组大小为5\*4，`prt_arr++`在上面的代码中实际上也是增加了20)此时出现了越界访问，`prt_arr`已经成为了野指针,可能会输出未知的数据，可能会直接报错。

### 6.3.1 数组长度不清导致的报错

```c
int arr[] = {1,2,3,4,5};
int(*ptr_arr)[] = &arr;
ptr_arr++;
```

上面这段代码会直接报错，原因在于虽然将数组的地址付给了指向数组的指针ptr_arr，但是ptr_arr在定义时没有说明自己指向的数组的大小。

这也说明了，在对指向数组的指针赋值时，并不会验证数组的大小与指向数组的指针所说明的大小是否一致
```c
int arr[5] = {1,2,3,4,5};

int (*ptr_arr)[10] = &arr;
int (*ptr_arr)[3] = &arr;
int (*ptr_arr)[10] = &arr;
//以上代码都可以正常编译运行
ptr_arr++;
```

值得注意的是，无论ptr_arr在定义是声明的长度为多少，对其加减都是跳过一个arr数组的大小，而非其所说明的大小。

> 明明定义指针时，无论如何说明大小，都是跳过一个数组的大小，但是不说明，在加减操作时还会提示长度不明确。很奇怪

### 6.3.2 对指向数组的指针sizeof

无论如何，指向数组的指针始终是一个指针变量，而非一个数组变量。
```c
int arr[] = {1,2,3,4,5};
int(*ptr)[] = &arr; 
sizeof(ptr);//无论如何声明和赋值，sizeof(ptr)的长度始终是一个指针的长度。而非其所指向的数组的长度。
```

### 6.3.3 将数组地址赋给非指向数组的指针

如果你要将一个数组的地址赋给一个非数组指针将发生什么？
```c
int arr[] = {1,2,3,4,5};
int* ptr = &arr;
```
这在一些C编译起上会报错，因为`&arr`是一个指向数组的指针（即`int (*)[]`类型的指针），而ptr是一个指向整型的指针（`int*`类型的指针）

但在一些编译器上，不会报错，而是等价与
```c
int *ptr = arr;
```
即将数组首元素的地址赋给ptr;

# 7.指针数组

指针变量也可以以数组的形式存储

```c
int a = 0;
int b = 1;

int* ptr1 = &a;
int* ptr2 = &b;

int* arr[] = {ptr1,ptr2};
```
上面代码的意义是，创建了一个数组，数组的每个元素是一个`int*`类型的指针；

## 7.1 通过指针数组来模仿二维数组

```c
int arr[][3] = {{1,2,3},{4,5,6}};
int(*ptr)[3] = arr;

printf("%d\n", **(ptr + 1));//输出4
printf("%d\n", ptr[1][0]);//输出4
printf("%d\n", *(*ptr + 1));//输出2
printf("%d\n", ptr[0][1]);//输出2
```

或是：

```c
int arr1[] = { 1,2,3 };
int arr2[] = { 4,5,6 };
int* ptr[] = { arr1,arr2 };

printf("%d\n", **(ptr + 1));//输出4
printf("%d\n", ptr[1][0]);//输出4
printf("%d\n", *(*ptr + 1));//输出2
printf("%d\n", ptr[0][1]);//输出2
```

> 上面两段代码的区别在于，第一段代码的空间是连续的，第二段代码的空间在每一行上连续，行与行之间并不连续。待验证

## 7.2 函数指针数组

我们可以实现一个数组，里面存放的是一组指向有相同参数和相同返回值的函数的指针。这就是函数指针数组。

```c
int funa(int a,int b);
int funb(int a,int b);
int func(int a,int b);

int(*ptr[])(int,int) = {funa,funb,func};
```

### 7.2.1 转移表

在C语言中，转移表（Jump Table）是一种使用函数指针数组实现的跳转表格。

它通常用于根据某个输入值选择不同的操作或函数来执行。转移表基于输入值的索引，将不同的操作或函数存储在数组中，然后通过索引来访问和执行相应的操作或函数。

转移表最好直接通过代码来理解。

```c
//使用转移表实现简单的计算器
int add(int a,int b){
 return a + b;
}//加法函数

int sub(int a,int b){
	return a-b;
}//减法函数

int  main(){
	int(*ptr[2])(int,int) = {add,sub};
	//创建一个函数指针数组来存放函数add和sub的地址
	int input;
	scanf("%d",&input);
	//获取一个输入
	switch(input)
	{
	case 1://当输入1时
		printf("%d",ptr[0](2,1));//计算2+1
		break;
	case 2://当输入2时
		printf("%d",ptr[1](2,1));//计算2-1
		break;
	}
	return 0;
}
```

# 8.对指针变量使用const

## 8.1 指向常量数据的指针

指针指向的数据为常量，不能修改，但可以修改指针包含的地址，即指针可以指向其他地方。

```c
int num = 10;
int sum = 20;
const int *ptr = &num;
*ptr = 10;//报错，无法通过指针来改变num的值
num =30;//但变量的值本身时可变的
ptr = &sum;//可以让指针指向别的同类型变量
```


## 8.2 常量的指针

指针包含的地址是常量，不能修改，但可修改指针指向的数据。

```c
int num = 10;
int sum = 20;
int* const ptr = &num;
*ptr = 20; // 可以通过指针改变变量的值
ptr = &sum //报错，指针无法指向别的地址
```


## 8.3 指针和其指向的值都是常量

指针包含的地址以及它指向的值都是常量，不能修改（这种组合最严格）。

```c
const int* const ptr = &num;
```

> 将指针传递给函数时，这些形式的const很有用。函数参数应声明为最严格的const指针，以确保函数不会修改指针指向的值。这让函数更容易维护，在时过境迁和人员更迭后尤其如此。
> 
# 9.对指针类型进行typedef

我们可以通过typedef来对变量类型进行重命名，如：
```c
typedef unsigned int size_t
```

此时我们把长整型`unsigned int`重命名为了`size_t`，在使用时，我们可以

```c
unsigned int a;
size_t a;
//在进行上面的typedef语句后，这两行代码等价
```

> 在c语言中，确实对`unsignedi int`重命名为了`size_t`，我们可以直接使用，不用自己去定义

指针变量也可以通过typedef重命名：

```c
typedef int* ptr_t
typedef char* ptr_ch
```

这样我们便可以

```c
ptr_t p;
int* p;
//在经过上面的typedef后，这两行代码等价
ptr_ch p;
char* ptr;
//在经过上面的typedef后，这两行代码等价
```

但是要注意的是，我们对指向数组的指针和指向函数的指针进行`typedef`

```c
typedef int(*ptr_fun)(int,int);
//对指向一个接收两个整型变量作为参数，返回类型为int的函数的指针类型进行重命名
int (*p)(int,int);
ptr_fun p;
//在经过上面的typedef后，这两行代码等价

typedef int(*ptr_arr)[10];
//对指向有10个int型元素的数组的指针类型进行重命名
int (*p)[10];
ptr_arr p;
//在经过上面的typedef后，这两行代码等价
```