在 C 语言中，字符串实际上是使用空字符`\0`结尾的一维字符数组。

**空字符（Null character）:**又称结束符，缩写`NUL`，是一个ASCLL值为`0`的控制字符，`\0`是转义字符，意思是告诉编译器，这不是字符`0`，而是空字符。

## 创建字符串

```c
char str[] = "ABC";
```

这创建了一个字符数组，相当于：
```c
char str[4]= {'A', 'B', 'C', '\0'};
```

我们也可以通过另一种方法创建一个字符串：
```c
char* str = "ABC";
```

这样实际上创建了一个字符串字面量，然后创建了一个`char*`类型的指针`str`指向这个字符串字面量的首地址。

## 两种创建方式的区别
我们知道，数组名其实就相当于数组首元素的地址，所以两种创建方式创建的字符串在使用上没有区别

```c
char str1[] = "ABC";
char* str2 = "ABC";
printf("%s",str1);
printf("%s",str2);
```

但是要注意，由于`str1`是字符数组，所以诸如`str1++`之类的代码会报错。无法改变数组名的地址。

而`str2`实际上是创建了一个字符串字面量，所以无法对值进行修改，也无法直接使得`str2`指向新的字符串字面量。但是其指向的地址可以改变，即诸如`str2++`的代码可以运行。

```c
*str2 = 'D';
str2[0] = 'C';
*str2 = "ABCD";
```

> 注意，上面的代码虽然不会报错，但是str的值并不会被改变
> 
```c
char* str2 = "ABC";
char* str3 = "DEF";
str2 = str3;
```

虽然`str2`无法直接指向别的字符串字面量，但是`str2`指向的地址是可变的，所以可以用以上代码可以间接改变`str2`，使其指向别的字符串字面量。

> 这只不过是间接的使`str2`指向了别的字符串字面量，但实际上原先指向的那个字符串字面量的值并没有被改变。

## string.h头文件中定义的函数
### strlen函数
用来获取一个字符串的长度
```c
size_t strlen(const char* str);
```
参数：要获取长度的字符串首元素地址

返回值：字符串长度

> 字符串以`\0`作为结束，strlen函数只返回`\0`前的字符个数，不包含`\0` 

### strcmp函数

```c
int strcmp( const char *lhs, const char *rhs );
```
作用：以字典序比较二个空终止字节字符串。

返回值：
- 如果两个字符串相等，则返回0。
- 否则返回字符串中首对不同字符（都转换为`unsigned char`类型）的值间的差；

> 若 `lhs` 或 `rhs` 不是指向空终止字节字符串的指针，则行为未定义。
### strncmp函数
```c
int strncmp( const char *lhs, const char *rhs, size_t count);
```
作用：比较二个可能空终止的字符数组的至多 `count` 个字符。按字典序进行比较。不比较后随空字符的字符。

返回值：
- 如果两个字符串相等，则返回0。
- 否则返回字符串中首对不同字符（都转换为`unsigned char`类型）的值间的差；

> 若出现越过 `lhs` 或 `rhs` 结尾的访问，则行为未定义。
> 
> 若 `lhs` 或 `rhs` 为空指针，则行为未定义。
### strcpy函数
```c
char* strcpy(char* dest, const char* src)
```
作用：将形参`src`所指向的字符串（包含\\0)，复制给形参`dest`所指向的字符数组

返回值：`dest`的副本

> 若 `dest` 数组长度不足则行为未定义
> 
> 若字符串覆盖则行为未定义。
> 
> 若 `dest` 不是指向字符数组的指针或 `src` 不是指向空终止字节字符串的指针则行为未定义。
### strncpy函数
```c
char* strcpy(char* dest, const char* src, size_t count);
```
作用：将形参`src`所指向的字符串至多`count`个字符，复制给形参`dest`所指向的字符串

> 若`count`小于字符串`src`的长度，则不会复制`src`的`\0`至`dest`中，则`dest`可能不是空终止的。
> 
> 若`count`大于`src`的长度，则在复制来自 `src` 的空终止字符后继续写入`\0`到`dest`中，直至到达`num`；

返回值：`dest`的副本

> 若字符数组重叠，则行为未定义。
> 
> 若 `dest` 或 `src` 不是指向字符数组的指针（包含若 `dest` 或 `src` 为空指针），则行为未定义。
> 
> 若 `dest` 所指向的数组大小小于 `count` ，或若 `src` 所指向的数组大小小于 `count` 且它不含空字符，则行为未定义。

### strcat函数
```c
char* strcat(char *dest, const char *src);
```
作用：将`src`所指向的字符串的值追加到`dest`字符串的后面

> 字符src[0]将会替换dest末尾的`\0`,但会追加自己的`\0`在新的dest字符串最后。

返回值：`dest`的副本

> 若目标数组对于 `src` 和 `dest` 的内容以及空终止符不够大，则行为未定义。
> 
> 若字符串重叠，则行为未定义。
> 
> 若 `dest` 或 `src` 不是指向空终止字节字符串的指针，则行为未定义。
### strncat函数
```c
char* strncat( char* dest, const char* src, size_t count);
```

作用：将`src`所指向的字符串最多`count`个字符追加到`dest`字符串的后面

> 字符 src[0]将会替换位于 `dest` 末尾的`\0`。始终会在`dest`的末尾附加一个`\0`（故函数可写入的最大字节数是 count+1 ）。

返回值：`dest`的副本

> 若目标数组没有对于 `dest` 和 `src` 的首 `count` 个字符加上终止空字符的足够空间，则行为未定义。
> 
> 若源与目标对象重叠，则行为未定义。
> 
> 若 `dest` 不是指向空终止字节字符串的指针，或 `src` 不是指向字符数组的指针，则行为未定义。
### strstr函数
```c
char *strstr(const char* str, const char* substr);
```
作用：查找 `substr` 所指的空终止字节字符串在 `str` 所指的空终止字节字符串中的首次出现。不比较空终止字符。

返回值：
	若 `substr` 指向空字符串，则返回 `str` 。
	若存在：指向于 `str` 中找到的子串首字符的指针。
	若不存在：返回空指针。

> 若 `str` 或 `substr` 不是指向空终止字节字符串的指针，则行为未定义。
### strerror函数
```c
char* strerror( int errnum );
```

参数：错误码

返回值:指向错误码所对应的错误信息字符串的地址

#### errno.h头文件和errno变量

在不同的系统和C语言标准库的实现中都规定了一些错误码，一般是放在`errno.h`这个头文件中说明的

C语言程序启动的时候就会使用一个全面的变量errno来记录程序的当前错误码
- 默认errno是0，表示没有错误
- 发生了错误时，将对应的错误码，存放在errno中

错误码实际上是一个整数，一个错误码对应一个错误信息。

### strtok函数
```c
char* strtok(char* str, const char* delim);
```
作用：寻找 `str` 所指向的空终止字节字符串中的下个标记(由 `delim` 所指向的空终止字节字符串中的所有字符都将作为标记).

> 函数被设置为可连续调用，以便在同一字符串中多次寻找下一个标记。

- 若 `str` 不是空指针，则调用被当做 `strtok` 对此特定字符串的首次调用。函数将在`str`中搜索首个不被包含在 `delim`中的字符。
	- 若找不到这种字符，则 `str` 中完全没有标记，或者全是标记，函数返回空指针。
	- 若找到这种字符，从这个字符开始搜索`str`中被包含在 `delim`中的字符。函数将会在调用结束时返回这个字符的地址
		- 若找不到这种字符，则 `str` 只有一个标记，下次对 `strtok` 的调用将返回空指针。函数返回。
		- 若找到这种字符，则用空字符 `\0` 替换它，并将指向下个标记的指针存储于静态位置，以为后继调用所用。函数返回。
- 若 `str` 为空指针，则将调用当做对 `strtok` 的后继调用，函数从先前调用中它剩下的位置开始。行为如同将先前存储的指针作为 str 传递。

> 此函数是破坏性的：它写入`\0` 字符到字符串 `str` 的元素。特别是,不能以字符串字面量为 `strtok` 的首参数。
> 
> 每次对 `strtok` 的调用都会修改静态对象：它不是线程安全的。
> 
> 不同于大多数其他记号化器， `strtok` 中的分隔符能对于后继记号不同，而且甚至能依赖于先前记号的内容。
> `strtok_s` 函数异于 POSIX `strtok_r`函数，前者通过在被记号化的字符串外部存储，和检查运行时制约来防护。

返回值：
- 有下一个标记：下个标记起始的指针，
- 无下一个标记：空指针。

> 若`str` 或 `delim` 不是指向空终止字节字符串的指针，则行为未定义。
