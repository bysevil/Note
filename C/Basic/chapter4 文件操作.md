如果没有文件，我们写的程序的数据是存储在电脑的内存中，如果程序退出，内存回收，数据就丢失了，等再次运行程序，是看不到上次程序的数据的，如果要将数据进行持久化的保存，我们可以使用文件

## 1.什么是文件
磁盘上的文件是文件。但是在程序设计中，我们一般谈的文件有两种：程序文件、数据文件（从文件功能的角度来分类的）。
- **程序文件：** 程序文件包括源程序文件（后缀为.c）,目标文件（windows环境后缀为.obj）,可执行程序（windows环境后缀为.exe）。
- **数据文件：** 文件的内容不一定是程序，而是程序运行时读写的数据，比如程序运行需要从中读取数据的文件，或者输出内容的文件。
### 1.1 文本文件和二进制文件
根据数据的组织形式，数据文件被称为文本文件或者二进制文件。

数据在内存中以二进制的形式存储，如果不加转换的输出到外存，就是二进制文件。

如果要求在外存上以ASCII码的形式存储，则需要在存储前转换。以ASCII字符的形式存储的文件就是文本文件。

一个数据在内存中是怎么存储的呢？字符一律以ASCII形式存储，数值型数据既可以用ASCII形式存储，也可以使用二进制形式存储。

如有整数10000，如果以ASCII码的形式输出到磁盘，则磁盘中占用5个字节（每个字符一个字节），而二进制形式输出，则在磁盘上只占4个字节（VS2019测试）。

## 2.流
我们程序的数据需要输出到各种外部设备，也需要从外部设备获取数据，不同的外部设备的输入输出操作各不相同。

为了方便程序员对各种设备进行方便的操作，我们抽象出了流的概念，我们可以把流想象成流淌着字符的河。

C程序针对文件、画面、键盘等的数据输入输出操作都是进行流操作的。

一般情况下，我们要想向流里写数据，或者从流中读取数据，都是要打开流，然后操作。

### 2.1 标准流
那为什么我们从键盘输入数据，向屏幕上输出数据，并没有打开流呢？那是因为C语言程序在启动的时候，默认打开了3个流：
- **stdin：** 标准输入流，在大多数的环境中从键盘输入。
- **stdout：** 标准输出流，大多数的环境中输出至显示器界面。
- **stderr：** 标准错误流，大多数环境中输出到显示器界面。

因为默认打开了这三个流，我们使用`scanf`、`printf`等函数就可以直接进行标准流的输入输出操作。

stdin、stdout、stderr三个流的类型是：**FILE\***，通常称为文件指针（文件类型的指针）。

C语言中，就是通过FILE\*的文件指针来维护流的各种操作的。

## 3.FIFE*类型的定义

```c
struct _ iobuf {
	char    *_ptr;
	int     _cnt;
	char    *_base;
	int     _flag;
	int     _file;
	int     _charbuf;
	int     _bufsiz;
	char    *_tmpfname;        
	};
typedef struct _ iobuf FILE   
```

## 4.文件的打开和关闭
文件在读写之前应该先打开文件，在使用结束之后应该关闭文件。

在编写程序的时候，在打开文件的同时，都会返回一个`FILE*`类型的指针变量指向该文件，也相当于建立了指针和文件的关系。ANSIC规定使用`fopen`函数来打开文件，`fclose`来关闭文件。

```c
//打开文件
FILE * fopen ( const char * filename, const char * mode)
//关闭文件
int fclose ( FILE * stream );
```
- filename ：要打开的文件的文件名，如果程序文件和要打开的文件不在一个目录，还需加上路径（相对路径和绝对路径都支持）
- mode：文件的打开方式

|文件打开方式|含义|如果指定文件不存在|
|--|--|--|
|“w”（只写）|为了输出数据，打开一个文本文件|建立一个新的文件|
|“a”（追加）|向文本文件尾添加数据|建立一个新的文件|
|“rb”（只读）|为了输入数据，打开一个二进制文件|出错|
|“wb”（只写）|为了输出数据，打开一个二进制文件|建立一个新的文件|
|“ab”（追加）|向一个二进制文件尾添加数据|建立一个新的文件|
|“r+”（读写）|为了读和写，打开一个文本文件|出错|
|“w+”（读写）|为了读和写，建议一个新的文件|建立一个新的文件|
|“a+”（读写）|打开一个文件，在文件尾进行读写|建立一个新的文件|
|“rb+”（读写）|为了读和写打开一个二进制文件|出错|
|“wb+”（读写）|为了读和写，新建一个新的二进制文件|建立一个新的文件|
|“ab+”（读写）|打开一个二进制文件，在文件尾进行读和写|建立一个新的文件|

```c
FILE* fp = fopen("data.txt","r");
//以只读类型打开文件，并创建一个文件指针`fp`指向这个文件的首部。
fclose(fp);
//关闭fp指向的文件
```

## 5.文件内部指针
除了指向文件首部的指针之外，还有一个指向文件内部的指针。

在对文件进行读写操作时，文件内部指针的位置会改变。(文件类型的指针位置始终指向文件首部不变)。

比如我向文件中写入1字符，则文件内部指针向后移动1字节，写入2字符，则文件内部指针向后移动2字节。（读取时文件内部指针也会后移）

> 如果没有这个自动移动的文件内部指针，很容易想到的是，如果我们对文件进行操作，那么则一直在对文件首部进行操作。
> 
> 比如我不断的给文件内写入字符，如果文件内部指针一直不移动，则我们始终在读写文件的第一个字符。

### 5.1 ftell
返回文件内部指针相对于文件首部的偏移量
```c
long int ftell ( FILE * stream );
```
### 5.2 rewind
让文件内部指针回到文件首部
```c
void rewind ( FILE * stream );
```
### 5.3 fseek
让文件指针相对于某个位置偏移一定的字节
```c
int fseek ( FILE * stream, long int offset, int origin );
```
注意第三个参数`origin`有三个值
- SEEK_SET : 文件首部
- SEEK_CUR : 文件内部指针的当前位置
- SEEK_END : 文件尾部

第二个参数是偏移量，可以为负数。

函数会将文件内部指针的位置改变为相对于`origin`偏移`offset`后的位置。

## 6.文件的读写
### 6.1 读操作（输入）
#### 6.1.1 fgetc
作用：字符输入函数，
适用：所有输入流
```c
fgetc(fp);//读取当前文件内部指针指向的字符
```
#### 6.1.2 fgets
作用：文本行输入函数
适用：所有输入流
```c
fgets(char* str, int num, FILE* Stream);
//在当前文本行内读取指定数量的字符,储存到字符串内
```
> 当读取到达行尾是时，读取结束，不会读取下一行的内容
#### 6.1.3 fscanf
作用：格式化输入函数
适用：所有输入流
```c
fscanf(FIFE* Stream,"格式字符串",格式表···);
```
> 与scanf的参数相比，只是在格式字符串前增加了一个参数来指定要读取的流
#### 6.1.4 fread
作用：二进制输入
适用：文件流
```c
size_t fread(void* buffer, size_t size, size_t count,FILE* Stream );
```
参数作用：
- buffer ：指向要储存读取结果的指针
- size ：每个对象的字节大小
- count ：有几个对象
- Stream ：要读取的流

返回：读取了多少个对象，如果正常读取，则返回值应与`count`相等。

> 不相等时可能遇到错误，也可能时读取到了文件尾部

### 6.2 写操作
#### 6.2.1 fputc
作用：字符输出函数，
适用：所有输出流
```c
fputc(char ch,FILE* Stream);//向文件内输出一个字符
```
#### 6.2.2 fputs
作用：文本行输出函数
适用：所有输出流
```c
fputs(char* str,FILE* Stream);//向文件内输出一个字符串
```
#### 6.2.3 fprintf
作用：格式化输出函数
适用：所有输出流
```c
fprintf(FILE* Stream,"格式字符串",格式表···);
```
> 与printf的参数相比相比，只是在格式字符串前增加了一个参数来指定要读取的流
#### 6.2.4 fwrite
作用：二进制输出
适用：文件流
```c
size_t fwrite(const void *buffer, size_t size, size_t count,FILE* Stream);
```
参数作用：
- buffer ：指向要写入对象的指针
- size ：每个对象的字节大小
- count ：有几个对象
- Stream ：输出到对应流

返回值：写入了多少个对象，如果正常写入，则返回值应与`count`相等。

## 7.文件的尾部
我们用`EOF`来标识文件的尾部。由编译器自动的在文件结尾添加标识。
```c
#define EOF -1
```
### 7.1 判断是否到达了文件尾部
我们用`feof`函数来判断是否到达了文件尾部
```c
int feof(FILE* Stream);
```
返回值：为当前文件内部指针到文件尾部的距离。
- 到达文件尾部时为0
- 未达文件尾部时为正值
> feof判断的是是否到达文件尾部，不能判断文件是否读取结束。

> 文件在正常读取结束时，会到达文件尾部，导致feof达到了判断文件是否读取结束的作用。
>
> 但这实际上存在隐患，所以不要使用feof来判断文件读取是否结束

## 8.判断文件是否读取结束
- 文本文件
	- 使用fgetc判断是否读到了EOF。
	- 使用fgets判断返回值是否为NULL。
- 二进制文件
	- 使用fread判断返回值是否小于实际要读的个数。