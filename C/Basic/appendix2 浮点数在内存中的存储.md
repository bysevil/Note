
## IEEE754标准的二进制表示方式
根据国际标准IEEE754，任意一个二进制浮点数V可以表示成下面的形式：
$$V = (−1)^S * M * 2^E$$

- $(-1)^S$表示符号位
	- 当S=0，V为正数
	- 当S=1，V为负数

- $M$表示有效数字
	- $1 <= M < 2$

- $2^E$表示指数位

> 举例来说
>
> 十进制的$5.0$，写成二进制是$101.0$，相当于$1.01*2^2$。
>
> 那么，按照上面V的格式，可以得出$S=0$，$M=1.01$，$E=2$。
> 
> 十进制的$-5.0$，写成二进制是$-101.0$，相当于$-1.01×2^2$。
> 
> 那么，$S=1$，$M=1.01$，$E=2$。

## IEEE754标准的二进制储存方式
IEEE754规定：
- 对于32位的浮点数
	- 最高的1位存储符号位S
	- 接着的8位存储指数E，
	- 剩下的23位存储有效数字M
- 对于64位的浮点数
	- 最高的1位存储符号位S
	- 接着的11位存储指数E
	- 剩下的52位存储有效数字M

## 具体的储存过程
### M的存储方式
前面说过，$1≤M<2$,也就是说，M可以写成1.xxxxxx的形式，其中xxxxxx表示小数部分。

IEEE754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。

比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。

### E的存储方式
这意味着，如果E为8位，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047。

但是，我们知道，科学计数法中的E是可以出现负数的

所以IEEE754规定，存入内存时E的真实值必须再加上一个中间数
- 对于8位的E，这个中间数是127；
- 对于11位的E，这个中间数是1023。
比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。

比如：0.5的二进制形式为0.1，由于规定正数部分必须为1，即将小数点右移1位，则为$1.0*2^{-1}$，其阶码为-1+127(中间值)=126，表示为01111110，而尾数1.0去掉整数部分为0，补⻬0到23位00000000000000000000000,则其二进制表示形式为:;
$$0\quad01111110\quad00000000000000000000000$$
## 浮点数的取出过程
### E不为全0或者全1
1. 即指数E的计算值减去127（或1023），得到真实值。
2. 再将有效数字M前加上第一位的1。
### E全为0
这时，浮点数的指数E等于1-127（或者1-1023）即为真实值，有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。
### E全为1
这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）;